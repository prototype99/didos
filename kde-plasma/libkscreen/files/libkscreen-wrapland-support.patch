From 3a7e55a0104f0688ca762777bac6e256c36e014b Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 6 Jan 2020 03:51:33 +0100
Subject: [PATCH 1/3] feat(kwayland): allow other extensions

Besides the KWayland output-management protocol there are other
protocols for output-management, for example wlroot's
wlr-output-management-unstable-v1 and kwinft_output_management_unstable_v1
protocols.

This patch refactors the backend such that alternative extensions
can be queried by KScreen through a plugin structure.
---
 CONTRIBUTING.md                               |   2 +-
 backends/kwayland/CMakeLists.txt              |  15 +
 backends/kwayland/plugins/CMakeLists.txt      |   1 +
 .../kwayland/plugins/kwayland/CMakeLists.txt  |  29 ++
 .../kwayland/plugins/kwayland/kwayland.json   |   7 +
 .../plugins/kwayland/kwayland_interface.cpp   | 240 +++++++++++
 .../plugins/kwayland/kwayland_interface.h     |  93 +++++
 .../plugins/kwayland/kwayland_output.cpp      | 223 ++++++++++
 .../plugins/kwayland/kwayland_output.h        |  75 ++++
 backends/kwayland/wayland_interface.cpp       | 128 ++++++
 backends/kwayland/wayland_interface.h         | 107 +++++
 backends/kwayland/waylandbackend.cpp          |   7 +-
 backends/kwayland/waylandbackend.h            |   4 -
 backends/kwayland/waylandconfig.cpp           | 383 +++++-------------
 backends/kwayland/waylandconfig.h             | 106 ++---
 backends/kwayland/waylandoutput.cpp           | 217 +---------
 backends/kwayland/waylandoutput.h             |  80 ++--
 backends/kwayland/waylandscreen.cpp           |   3 +-
 18 files changed, 1125 insertions(+), 595 deletions(-)
 create mode 100644 backends/kwayland/plugins/CMakeLists.txt
 create mode 100644 backends/kwayland/plugins/kwayland/CMakeLists.txt
 create mode 100644 backends/kwayland/plugins/kwayland/kwayland.json
 create mode 100644 backends/kwayland/plugins/kwayland/kwayland_interface.cpp
 create mode 100644 backends/kwayland/plugins/kwayland/kwayland_interface.h
 create mode 100644 backends/kwayland/plugins/kwayland/kwayland_output.cpp
 create mode 100644 backends/kwayland/plugins/kwayland/kwayland_output.h
 create mode 100644 backends/kwayland/wayland_interface.cpp
 create mode 100644 backends/kwayland/wayland_interface.h

diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 96f12fa..245ed61 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -33,9 +33,9 @@ Besides the [KDE Commit Policy][commit-policy] the [Conventional Commits 1.0.0][
   * test: addition of a new test or correction of an existing one
 * Only the following optional scopes are allowed:
   * api
-  * kwayland
   * qscreen
   * randr
+  * wayland
 * Angular's [Revert][angular-revert] and [Subject][angular-subject] policies are applied.
 * Breaking changes are supposed to be pointed out only in prose in the commit body.
 * When a commit closes a bug on [Bugzilla][bugzilla] or when the commit has an associated Phabricator review special keywords must be used in the commit body to link the respective bug or review. See [here][commit-policy-keywords] for more information on these and other possible keywords. [Arcanist][arcanist] should be used for automating usage of the review keyword.
diff --git a/backends/kwayland/CMakeLists.txt b/backends/kwayland/CMakeLists.txt
index 2c43098..6d94d57 100644
--- a/backends/kwayland/CMakeLists.txt
+++ b/backends/kwayland/CMakeLists.txt
@@ -1,15 +1,29 @@
+find_package(KF5 ${KF5_MIN_VERSION} REQUIRED COMPONENTS
+    CoreAddons
+)
 
 set(wayland_SRCS
     waylandbackend.cpp
     waylandconfig.cpp
+    wayland_interface.cpp
     waylandoutput.cpp
     waylandscreen.cpp
     ../utils.cpp
 )
+
+ecm_qt_declare_logging_category(
+    wayland_SRCS
+    HEADER wayland_logging.h
+    IDENTIFIER KSCREEN_WAYLAND
+    CATEGORY_NAME org.kde.kscreen.wayland
+)
+
 qt5_add_dbus_interface(wayland_SRCS org.kde.KWin.TabletModeManager.xml tabletmodemanager_interface)
 
 add_library(KSC_KWayland MODULE ${wayland_SRCS})
 
+add_subdirectory(plugins)
+
 set_target_properties(KSC_KWayland PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/kf5/kscreen")
 set_target_properties(KSC_KWayland PROPERTIES PREFIX "")
 target_link_libraries(KSC_KWayland Qt5::Core
@@ -17,6 +31,7 @@ target_link_libraries(KSC_KWayland Qt5::Core
                                   Qt5::Gui
                                   KF5::Screen
                                   KF5::WaylandClient
+                                  KF5::CoreAddons
 )
 
 install(TARGETS KSC_KWayland DESTINATION ${KDE_INSTALL_PLUGINDIR}/kf5/kscreen/)
diff --git a/backends/kwayland/plugins/CMakeLists.txt b/backends/kwayland/plugins/CMakeLists.txt
new file mode 100644
index 0000000..77c3628
--- /dev/null
+++ b/backends/kwayland/plugins/CMakeLists.txt
@@ -0,0 +1 @@
+add_subdirectory(kwayland)
diff --git a/backends/kwayland/plugins/kwayland/CMakeLists.txt b/backends/kwayland/plugins/kwayland/CMakeLists.txt
new file mode 100644
index 0000000..7b90579
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/CMakeLists.txt
@@ -0,0 +1,29 @@
+set(kwayland_SRCS
+    kwayland_interface.cpp
+    kwayland_output.cpp
+    ../../wayland_interface.cpp
+    ../../waylandoutput.cpp
+    ../../wayland_logging.cpp
+    ../../../utils.cpp
+)
+
+include_directories(${CMAKE_SOURCE_DIR}/backends/kwayland)
+
+add_library(LibkscreenWaylandPluginKWayland MODULE ${kwayland_SRCS})
+
+set_target_properties(LibkscreenWaylandPluginKWayland
+    PROPERTIES LIBRARY_OUTPUT_DIRECTORY
+    "${CMAKE_BINARY_DIR}/bin/org.kde.libkscreen.backends/wayland/"
+)
+
+target_link_libraries(LibkscreenWaylandPluginKWayland
+    Qt5::Core
+    Qt5::Gui
+    KF5::Screen
+    KF5::WaylandClient
+)
+
+install(
+    TARGETS LibkscreenWaylandPluginKWayland
+    DESTINATION ${PLUGIN_INSTALL_DIR}/org.kde.libkscreen.backends/wayland/
+)
diff --git a/backends/kwayland/plugins/kwayland/kwayland.json b/backends/kwayland/plugins/kwayland/kwayland.json
new file mode 100644
index 0000000..62b2a0b
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/kwayland.json
@@ -0,0 +1,7 @@
+{
+    "KPlugin": {
+        "Description": "Wayland backend using KWayland library's output management interface.",
+        "Id": "LibkscreenWaylandPluginKWayland",
+        "Name": "kwayland"
+    }
+}
diff --git a/backends/kwayland/plugins/kwayland/kwayland_interface.cpp b/backends/kwayland/plugins/kwayland/kwayland_interface.cpp
new file mode 100644
index 0000000..1928e3d
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/kwayland_interface.cpp
@@ -0,0 +1,240 @@
+/*************************************************************************
+Copyright © 2013        Martin Gräßlin <mgraesslin@kde.org>
+Copyright © 2014-2015   Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "kwayland_interface.h"
+
+#include "waylandbackend.h"
+#include "kwayland_output.h"
+#include "waylandscreen.h"
+
+#include "../../wayland_logging.h"
+
+#include <KWayland/Client/connection_thread.h>
+#include <KWayland/Client/event_queue.h>
+#include <KWayland/Client/registry.h>
+#include <KWayland/Client/outputconfiguration.h>
+#include <KWayland/Client/outputmanagement.h>
+
+#include <QThread>
+
+using namespace KScreen;
+
+
+WaylandInterface* KWaylandFactory::createInterface(QObject *parent)
+{
+    return new KWaylandInterface(parent);
+}
+
+KWaylandInterface::KWaylandInterface(QObject *parent)
+    : WaylandInterface(parent)
+    , m_outputManagement(nullptr)
+    , m_registryInitialized(false)
+    , m_kscreenPendingConfig(nullptr)
+{
+}
+
+void KWaylandInterface::initConnection(QThread *thread)
+{
+    m_connection = new KWayland::Client::ConnectionThread;
+
+    connect(m_connection, &KWayland::Client::ConnectionThread::connected,
+            this, &KWaylandInterface::setupRegistry, Qt::QueuedConnection);
+
+    connect(m_connection, &KWayland::Client::ConnectionThread::connectionDied,
+            this, &KWaylandInterface::handleDisconnect, Qt::QueuedConnection);
+
+    connect(m_connection, &KWayland::Client::ConnectionThread::failed, this, [this] {
+        qCWarning(KSCREEN_WAYLAND) << "Failed to connect to Wayland server at socket:"
+                                   << m_connection->socketName();
+        Q_EMIT connectionFailed(m_connection->socketName());
+    });
+
+    m_connection->moveToThread(thread);
+    thread->start();
+    m_connection->initConnection();
+}
+
+bool KWaylandInterface::isInitialized() const
+{
+    return m_registryInitialized && m_outputManagement != nullptr
+            && WaylandInterface::isInitialized();
+}
+
+void KWaylandInterface::handleDisconnect()
+{
+    qDeleteAll(m_outputMap);
+    m_outputMap.clear();
+
+    // Clean up
+    if (m_queue) {
+        delete m_queue;
+        m_queue = nullptr;
+    }
+
+    m_connection->deleteLater();
+    m_connection = nullptr;
+
+    WaylandInterface::handleDisconnect();
+}
+
+void KWaylandInterface::setupRegistry()
+{
+    m_queue = new KWayland::Client::EventQueue(this);
+    m_queue->setup(m_connection);
+
+    m_registry = new KWayland::Client::Registry(this);
+
+    connect(m_registry, &KWayland::Client::Registry::outputDeviceAnnounced,
+            this, &KWaylandInterface::addOutputDevice);
+
+    connect(m_registry, &KWayland::Client::Registry::outputManagementAnnounced,
+            this, [this](quint32 name, quint32 version) {
+                m_outputManagement = m_registry->createOutputManagement(name, version, m_registry);
+            }
+    );
+
+    connect(m_registry, &KWayland::Client::Registry::interfacesAnnounced,
+            this, [this] {
+                m_registryInitialized = true;
+                unblockSignals();
+                checkInitialized();
+            }
+    );
+
+    m_registry->create(m_connection);
+    m_registry->setEventQueue(m_queue);
+    m_registry->setup();
+}
+
+int s_outputId = 0;
+
+void KWaylandInterface::addOutputDevice(quint32 name, quint32 version)
+{
+    KWaylandOutput *output = new KWaylandOutput(++s_outputId, this);
+    output->createOutputDevice(m_registry, name, version);
+    addOutput(output);
+}
+
+void KWaylandInterface::insertOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<KWaylandOutput*>(output);
+    m_outputMap.insert(out->id(), out);
+}
+
+WaylandOutput* KWaylandInterface::takeOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<KWaylandOutput*>(output);
+    return m_outputMap.take(out->id());
+}
+
+void KWaylandInterface::updateConfig(KScreen::ConfigPtr &config)
+{
+    config->setSupportedFeatures(Config::Feature::Writable | Config::Feature::PerOutputScaling
+                                 | Config::Feature::AutoRotation | Config::Feature::TabletMode);
+    config->setValid(m_connection->display());
+
+    //Removing removed outputs
+    const KScreen::OutputList outputs = config->outputs();
+    for (const auto &output : outputs) {
+        if (!m_outputMap.contains(output->id())) {
+            config->removeOutput(output->id());
+        }
+    }
+
+    // Add KScreen::Outputs that aren't in the list yet, handle primaryOutput
+    KScreen::OutputList kscreenOutputs = config->outputs();
+    for (const auto &output : m_outputMap) {
+        KScreen::OutputPtr kscreenOutput = kscreenOutputs[output->id()];
+        if (!kscreenOutput) {
+            kscreenOutput = output->toKScreenOutput();
+            kscreenOutputs.insert(kscreenOutput->id(), kscreenOutput);
+        }
+        if (kscreenOutput && m_outputMap.count() == 1) {
+            kscreenOutput->setPrimary(true);
+        } else if (m_outputMap.count() > 1) {
+            // primaryScreen concept doesn't exist in Wayland, so we don't set one
+        }
+        output->updateKScreenOutput(kscreenOutput);
+    }
+    config->setOutputs(kscreenOutputs);
+}
+
+QMap<int, WaylandOutput*> KWaylandInterface::outputMap() const
+{
+    QMap<int, WaylandOutput*> ret;
+
+    QMap<int, KWaylandOutput*>::const_iterator it = m_outputMap.constBegin();
+    while (it != m_outputMap.constEnd()) {
+        ret[it.key()] = it.value();
+        ++it;
+    }
+    return ret;
+}
+
+void KWaylandInterface::tryPendingConfig()
+{
+    if (!m_kscreenPendingConfig) {
+        return;
+    }
+    applyConfig(m_kscreenPendingConfig);
+    m_kscreenPendingConfig = nullptr;
+}
+
+void KWaylandInterface::applyConfig(const KScreen::ConfigPtr &newConfig)
+{
+    using namespace KWayland::Client;
+
+    // Create a new configuration object
+    auto wlConfig = m_outputManagement->createConfiguration();
+    bool changed = false;
+
+    if (signalsBlocked()) {
+        /* Last apply still pending, remember new changes and apply afterwards */
+        m_kscreenPendingConfig = newConfig;
+        return;
+    }
+
+    for (const auto &output : newConfig->outputs()) {
+        changed |= m_outputMap[output->id()]->setWlConfig(wlConfig, output);
+    }
+
+    if (!changed) {
+        return;
+    }
+
+    // We now block changes in order to compress events while the compositor is doing its thing
+    // once it's done or failed, we'll trigger configChanged() only once, and not per individual
+    // property change.
+    connect(wlConfig, &OutputConfiguration::applied, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+    connect(wlConfig, &OutputConfiguration::failed, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+
+    // Now block signals and ask the compositor to apply the changes.
+    blockSignals();
+    wlConfig->apply();
+}
diff --git a/backends/kwayland/plugins/kwayland/kwayland_interface.h b/backends/kwayland/plugins/kwayland/kwayland_interface.h
new file mode 100644
index 0000000..b26d42c
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/kwayland_interface.h
@@ -0,0 +1,93 @@
+/*************************************************************************
+Copyright © 2014-2015   Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "wayland_interface.h"
+#include "config.h"
+
+namespace KWayland
+{
+namespace Client
+{
+class ConnectionThread;
+class EventQueue;
+class Registry;
+class OutputManagement;
+}
+}
+
+namespace KScreen
+{
+class Output;
+class KWaylandOutput;
+class WaylandOutput;
+class WaylandScreen;
+
+class KWaylandFactory : public WaylandFactory
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.kde.libkscreen.waylandinterface" FILE "kwayland.json")
+
+public:
+    WaylandInterface* createInterface(QObject *parent = nullptr) override;
+};
+
+class KWaylandInterface : public WaylandInterface
+{
+    Q_OBJECT
+
+public:
+    explicit KWaylandInterface(QObject *parent = nullptr);
+    ~KWaylandInterface() override = default;
+    bool isInitialized() const override;
+
+    QMap<int, WaylandOutput*> outputMap() const override;
+
+    void applyConfig(const KScreen::ConfigPtr &newConfig) override;
+    void updateConfig(KScreen::ConfigPtr &config) override;
+
+protected:
+    void initConnection(QThread *thread) override;
+    void insertOutput(WaylandOutput *output) override;
+    WaylandOutput* takeOutput(WaylandOutput *output) override;
+    void handleDisconnect() override;
+
+private:
+    void setupRegistry();
+    void addOutputDevice(quint32 name, quint32 version);
+    void tryPendingConfig();
+
+    KWayland::Client::ConnectionThread *m_connection;
+    KWayland::Client::EventQueue *m_queue;
+
+    KWayland::Client::Registry *m_registry;
+    KWayland::Client::OutputManagement *m_outputManagement;
+
+    // KWayland names as keys
+    QMap<int, KWaylandOutput*> m_outputMap;
+
+    // KWayland names
+    int m_lastOutputId = -1;
+
+    bool m_registryInitialized;
+    bool m_blockSignals;
+    KScreen::ConfigPtr m_kscreenPendingConfig;
+};
+
+}
diff --git a/backends/kwayland/plugins/kwayland/kwayland_output.cpp b/backends/kwayland/plugins/kwayland/kwayland_output.cpp
new file mode 100644
index 0000000..d20baa3
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/kwayland_output.cpp
@@ -0,0 +1,223 @@
+/*************************************************************************
+Copyright © 2014-2015 Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "kwayland_output.h"
+
+#include "waylandbackend.h"
+#include "waylandconfig.h"
+#include "../utils.h"
+
+#include <mode.h>
+#include <edid.h>
+
+#include "../../wayland_logging.h"
+
+#include <KWayland/Client/outputconfiguration.h>
+#include <KWayland/Client/outputdevice.h>
+
+using namespace KScreen;
+namespace Wl = KWayland::Client;
+
+const QMap<Wl::OutputDevice::Transform, Output::Rotation>
+s_rotationMap = {
+    {Wl::OutputDevice::Transform::Normal, Output::None},
+    {Wl::OutputDevice::Transform::Rotated90, Output::Right},
+    {Wl::OutputDevice::Transform::Rotated180, Output::Inverted},
+    {Wl::OutputDevice::Transform::Rotated270, Output::Left},
+    {Wl::OutputDevice::Transform::Flipped, Output::None},
+    {Wl::OutputDevice::Transform::Flipped90, Output::Right},
+    {Wl::OutputDevice::Transform::Flipped180, Output::Inverted},
+    {Wl::OutputDevice::Transform::Flipped270, Output::Left}
+};
+
+Output::Rotation toKScreenRotation(const Wl::OutputDevice::Transform transform)
+{
+    auto it = s_rotationMap.constFind(transform);
+    return it.value();
+}
+
+Wl::OutputDevice::Transform toKWaylandTransform(const Output::Rotation rotation)
+{
+    return s_rotationMap.key(rotation);
+}
+
+KWaylandOutput::KWaylandOutput(quint32 id, QObject *parent)
+    : WaylandOutput(id, parent)
+    , m_device(nullptr)
+{
+}
+
+bool KWaylandOutput::enabled() const
+{
+    return m_device != nullptr;
+}
+
+QByteArray KWaylandOutput::edid() const
+{
+    return m_device->edid();
+}
+
+QRectF KWaylandOutput::geometry() const
+{
+    return m_device->geometry();
+}
+
+Wl::OutputDevice* KWaylandOutput::outputDevice() const
+{
+    return m_device;
+}
+
+void KWaylandOutput::createOutputDevice(Wl::Registry *registry, quint32 name, quint32 version)
+{
+    Q_ASSERT(!m_device);
+    m_device = registry->createOutputDevice(name, version);
+
+    connect(m_device, &Wl::OutputDevice::removed, this, &KWaylandOutput::removed);
+    connect(m_device, &Wl::OutputDevice::done, this, [this]() {
+                Q_EMIT dataReceived();
+                connect(m_device, &Wl::OutputDevice::changed, this, &KWaylandOutput::changed);
+    });
+}
+
+void KWaylandOutput::updateKScreenOutput(OutputPtr &output)
+{
+    // Initialize primary output
+    output->setEnabled(m_device->enabled() == Wl::OutputDevice::Enablement::Enabled);
+    output->setConnected(true);
+    output->setPrimary(true); // FIXME: wayland doesn't have the concept of a primary display
+    output->setName(name());
+    output->setSizeMm(m_device->physicalSize());
+    output->setPos(m_device->globalPosition());
+    output->setRotation(s_rotationMap[m_device->transform()]);
+
+    ModeList modeList;
+    QStringList preferredModeIds;
+    m_modeIdMap.clear();
+    QString currentModeId = QStringLiteral("-1");
+
+    for (const Wl::OutputDevice::Mode &wlMode : m_device->modes()) {
+        ModePtr mode(new Mode());
+        const QString name = modeName(wlMode);
+
+        QString modeId = QString::number(wlMode.id);
+        if (modeId.isEmpty()) {
+            qCDebug(KSCREEN_WAYLAND) << "Could not create mode id from"
+                                     << wlMode.id << ", using" << name << "instead.";
+            modeId = name;
+        }
+
+        if (m_modeIdMap.contains(modeId)) {
+            qCWarning(KSCREEN_WAYLAND) << "Mode id already in use:" << modeId;
+        }
+        mode->setId(modeId);
+
+        // KWayland gives the refresh rate as int in mHz
+        mode->setRefreshRate(wlMode.refreshRate / 1000.0);
+        mode->setSize(wlMode.size);
+        mode->setName(name);
+
+        if (wlMode.flags.testFlag(Wl::OutputDevice::Mode::Flag::Current)) {
+            currentModeId = modeId;
+        }
+        if (wlMode.flags.testFlag(Wl::OutputDevice::Mode::Flag::Preferred)) {
+            preferredModeIds << modeId;
+        }
+
+        // Update the kscreen => kwayland mode id translation map
+        m_modeIdMap.insert(modeId, wlMode.id);
+        // Add to the modelist which gets set on the output
+        modeList[modeId] = mode;
+    }
+
+    if (currentModeId == QLatin1String("-1")) {
+        qCWarning(KSCREEN_WAYLAND) << "Could not find the current mode id" << modeList;
+    }
+
+    output->setCurrentModeId(currentModeId);
+    output->setPreferredModes(preferredModeIds);
+    output->setModes(modeList);
+    output->setScale(m_device->scaleF());
+    output->setType(Utils::guessOutputType(m_device->model(), m_device->model()));
+}
+
+bool KWaylandOutput::setWlConfig(Wl::OutputConfiguration *wlConfig,
+                                const KScreen::OutputPtr &output)
+{
+    bool changed = false;
+
+    // enabled?
+    if ((m_device->enabled() == Wl::OutputDevice::Enablement::Enabled)
+            != output->isEnabled()) {
+        changed = true;
+        const auto enablement = output->isEnabled() ? Wl::OutputDevice::Enablement::Enabled :
+                                                      Wl::OutputDevice::Enablement::Disabled;
+        wlConfig->setEnabled(m_device, enablement);
+    }
+
+    // position
+    if (m_device->globalPosition() != output->pos()) {
+        changed = true;
+        wlConfig->setPosition(m_device, output->pos());
+    }
+
+    // scale
+    if (!qFuzzyCompare(m_device->scaleF(), output->scale())) {
+        changed = true;
+        wlConfig->setScaleF(m_device, output->scale());
+    }
+
+    // rotation
+    if (toKScreenRotation(m_device->transform()) != output->rotation()) {
+        changed = true;
+        wlConfig->setTransform(m_device, toKWaylandTransform(output->rotation()));
+    }
+
+    // mode
+    if (m_modeIdMap.contains(output->currentModeId())) {
+        const int newModeId = m_modeIdMap.value(output->currentModeId(), -1);
+        if (newModeId != m_device->currentMode().id) {
+            changed = true;
+            wlConfig->setMode(m_device, newModeId);
+        }
+    } else {
+        qCWarning(KSCREEN_WAYLAND) << "Invalid kscreen mode id:" << output->currentModeId()
+                                   << "\n\n" << m_modeIdMap;
+    }
+    return changed;
+}
+
+QString KWaylandOutput::modeName(const Wl::OutputDevice::Mode &m) const
+{
+    return QString::number(m.size.width()) + QLatin1Char('x') +
+           QString::number(m.size.height()) + QLatin1Char('@') +
+           QString::number(qRound(m.refreshRate/1000.0));
+}
+
+QString KWaylandOutput::name() const
+{
+    Q_ASSERT(m_device);
+    return QStringLiteral("%1 %2").arg(m_device->manufacturer(), m_device->model());
+}
+
+QDebug operator<<(QDebug dbg, const KWaylandOutput *output)
+{
+    dbg << "KWaylandOutput(Id:" << output->id() <<", Name:" << \
+        QString(output->outputDevice()->manufacturer() + QLatin1Char(' ') + \
+        output->outputDevice()->model())  << ")";
+    return dbg;
+}
diff --git a/backends/kwayland/plugins/kwayland/kwayland_output.h b/backends/kwayland/plugins/kwayland/kwayland_output.h
new file mode 100644
index 0000000..0e868f0
--- /dev/null
+++ b/backends/kwayland/plugins/kwayland/kwayland_output.h
@@ -0,0 +1,75 @@
+/*************************************************************************
+Copyright © 2014-2015 Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "waylandoutput.h"
+
+#include "output.h"
+
+#include <KWayland/Client/outputdevice.h>
+#include <KWayland/Client/registry.h>
+
+#include <QLoggingCategory>
+#include <QScreen>
+#include <QSize>
+
+namespace KWayland
+{
+namespace Client
+{
+class OutputConfiguration;
+}
+}
+
+namespace KScreen
+{
+
+class KWaylandOutput : public WaylandOutput
+{
+    Q_OBJECT
+
+public:
+    explicit KWaylandOutput(quint32 id, QObject *parent = nullptr);
+    ~KWaylandOutput() override = default;
+
+    void updateKScreenOutput(KScreen::OutputPtr &output) override;
+
+    QString name() const;
+    QByteArray edid() const override;
+    bool enabled() const override;
+    QRectF geometry() const override;
+
+    KWayland::Client::OutputDevice* outputDevice() const;
+    void createOutputDevice(KWayland::Client::Registry *registry, quint32 name, quint32 version);
+
+    bool setWlConfig(KWayland::Client::OutputConfiguration *wlConfig,
+                   const KScreen::OutputPtr &output);
+
+private:
+    void showOutput();
+    QString modeName(const KWayland::Client::OutputDevice::Mode &m) const;
+
+    KWayland::Client::OutputDevice *m_device;
+    KWayland::Client::Registry *m_registry;
+
+    // left-hand-side: KScreen::Mode, right-hand-side: KWayland's mode.id
+    QMap<QString, int> m_modeIdMap;
+};
+
+}
diff --git a/backends/kwayland/wayland_interface.cpp b/backends/kwayland/wayland_interface.cpp
new file mode 100644
index 0000000..3665f8f
--- /dev/null
+++ b/backends/kwayland/wayland_interface.cpp
@@ -0,0 +1,128 @@
+/*************************************************************************
+Copyright © 2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "wayland_interface.h"
+
+#include "waylandbackend.h"
+#include "waylandoutput.h"
+#include "waylandscreen.h"
+
+#include <configmonitor.h>
+#include <mode.h>
+
+#include "../../wayland_logging.h"
+
+#include <QThread>
+#include <QTimer>
+
+using namespace KScreen;
+
+WaylandInterface::WaylandInterface(QObject *parent)
+    : QObject(parent)
+    , m_blockSignals(true)
+    , m_kscreenConfig(new Config)
+{
+}
+
+WaylandInterface::~WaylandInterface() = default;
+
+bool WaylandInterface::signalsBlocked() const
+{
+    return m_blockSignals;
+}
+
+void WaylandInterface::blockSignals()
+{
+    Q_ASSERT(m_blockSignals == false);
+    m_blockSignals = true;
+}
+
+void WaylandInterface::unblockSignals()
+{
+    Q_ASSERT(m_blockSignals == true);
+    m_blockSignals = false;
+}
+
+void WaylandInterface::handleDisconnect()
+{
+    qCWarning(KSCREEN_WAYLAND) << "Wayland disconnected, cleaning up.";
+    Q_EMIT configChanged();
+}
+
+void WaylandInterface::addOutput(WaylandOutput *output)
+{
+    m_initializingOutputs << output;
+
+    connect(output, &WaylandOutput::removed,
+            this, [this, output]() { removeOutput(output); });
+    connect(output, &WaylandOutput::dataReceived,
+            this, [this, output]() { initOutput(output); });
+}
+
+void WaylandInterface::initOutput(WaylandOutput *output)
+{
+    insertOutput(output);
+    m_initializingOutputs.removeOne(output);
+    checkInitialized();
+
+    if (!signalsBlocked() && m_initializingOutputs.empty()) {
+        Q_EMIT outputsChanged();
+        Q_EMIT configChanged();
+    }
+
+    connect(output, &WaylandOutput::changed, this, [this]() {
+        if (!signalsBlocked()) {
+            Q_EMIT configChanged();
+        }
+    });
+}
+
+void WaylandInterface::removeOutput(WaylandOutput *output)
+{
+    if (m_initializingOutputs.removeOne(output)) {
+        // Output was not yet fully initialized, just remove here and return.
+        delete output;
+        return;
+    }
+
+    // remove the output from output mapping
+    const auto removedOutput = takeOutput(output);
+    Q_ASSERT(removedOutput == output); Q_UNUSED(removedOutput);
+    Q_EMIT outputsChanged();
+    delete output;
+
+    if (!m_blockSignals) {
+        Q_EMIT configChanged();
+    }
+}
+
+void WaylandInterface::checkInitialized()
+{
+    if (isInitialized()) {
+        Q_EMIT initialized();
+    }
+}
+
+bool WaylandInterface::isInitialized() const
+{
+    return !m_blockSignals && m_initializingOutputs.isEmpty() && outputMap().count();
+}
+
+void WaylandInterface::applyConfig(const KScreen::ConfigPtr &newConfig)
+{
+    Q_UNUSED(newConfig)
+}
diff --git a/backends/kwayland/wayland_interface.h b/backends/kwayland/wayland_interface.h
new file mode 100644
index 0000000..1deed9a
--- /dev/null
+++ b/backends/kwayland/wayland_interface.h
@@ -0,0 +1,107 @@
+/*************************************************************************
+Copyright © 2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "config.h"
+
+#include <QEventLoop>
+#include <QObject>
+#include <QVector>
+
+class QThread;
+
+namespace KScreen
+{
+class Output;
+class WaylandOutput;
+class WaylandScreen;
+
+class WaylandInterface : public QObject
+{
+    Q_OBJECT
+
+public:
+    enum class Type {
+        KWayland = 0,
+    };
+
+    ~WaylandInterface() override;
+
+    virtual void initConnection(QThread *thread) = 0;
+    virtual bool isInitialized() const;
+
+    // Compositor side names as keys
+    virtual QMap<int, WaylandOutput*> outputMap() const = 0;
+
+    virtual void applyConfig(const KScreen::ConfigPtr &newConfig);
+    virtual void updateConfig(KScreen::ConfigPtr &config) = 0;
+
+Q_SIGNALS:
+    void configChanged();
+    void initialized();
+    void connectionFailed(const QString &socketName);
+    void outputsChanged();
+
+protected:
+    explicit WaylandInterface(QObject *parent = nullptr);
+
+    virtual void insertOutput(WaylandOutput *output) = 0;
+    virtual WaylandOutput* takeOutput(WaylandOutput *output) = 0;
+
+    bool signalsBlocked() const;
+    void blockSignals();
+    void unblockSignals();
+
+    void checkInitialized();
+
+    void addOutput(WaylandOutput *output);
+    virtual void handleDisconnect();
+
+private:
+    void removeOutput(WaylandOutput *output);
+
+    /**
+     * Finalize: when the output is is initialized, we put it in the known outputs map,
+     * remove it from the list of initializing outputs, and emit configChanged().
+     */
+    virtual void initOutput(WaylandOutput *output);
+
+    void tryPendingConfig();
+
+    // Compositor side names
+    QList<WaylandOutput*> m_initializingOutputs;
+    int m_lastOutputId = -1;
+
+    bool m_blockSignals;
+    KScreen::ConfigPtr m_kscreenConfig;
+    WaylandScreen *m_screen;
+};
+
+class WaylandFactory : public QObject
+{
+    Q_OBJECT
+public:
+    WaylandFactory(QObject *parent = nullptr) : QObject(parent) {}
+    ~WaylandFactory() override = default;
+
+    virtual WaylandInterface* createInterface(QObject *parent = nullptr) = 0;
+};
+
+}
+
+Q_DECLARE_INTERFACE(KScreen::WaylandFactory, "org.kde.libkscreen.waylandinterface")
diff --git a/backends/kwayland/waylandbackend.cpp b/backends/kwayland/waylandbackend.cpp
index 98ffce8..2108f18 100644
--- a/backends/kwayland/waylandbackend.cpp
+++ b/backends/kwayland/waylandbackend.cpp
@@ -22,6 +22,8 @@
 #include "waylandconfig.h"
 #include "waylandoutput.h"
 
+#include "wayland_logging.h"
+
 #include <configmonitor.h>
 #include <mode.h>
 
@@ -30,9 +32,6 @@
 
 using namespace KScreen;
 
-Q_LOGGING_CATEGORY(KSCREEN_WAYLAND, "kscreen.kwayland")
-
-
 WaylandBackend::WaylandBackend()
     : KScreen::AbstractBackend()
     , m_internalConfig(new WaylandConfig(this))
@@ -75,7 +74,7 @@ QByteArray WaylandBackend::edid(int outputId) const
     if (!output) {
         return QByteArray();
     }
-    return output->outputDevice()->edid();
+    return output->edid();
 }
 
 bool WaylandBackend::isValid() const
diff --git a/backends/kwayland/waylandbackend.h b/backends/kwayland/waylandbackend.h
index 3f21aed..8839981 100644
--- a/backends/kwayland/waylandbackend.h
+++ b/backends/kwayland/waylandbackend.h
@@ -21,8 +21,6 @@
 
 #include "abstractbackend.h"
 
-#include <QLoggingCategory>
-
 namespace KScreen
 {
 
@@ -49,5 +47,3 @@ private:
 };
 
 }
-
-Q_DECLARE_LOGGING_CATEGORY(KSCREEN_WAYLAND)
diff --git a/backends/kwayland/waylandconfig.cpp b/backends/kwayland/waylandconfig.cpp
index 9f2f95f..709e9c9 100644
--- a/backends/kwayland/waylandconfig.cpp
+++ b/backends/kwayland/waylandconfig.cpp
@@ -1,75 +1,55 @@
-/*************************************************************************************
- *  Copyright 2014-2015 Sebastian Kügler <sebas@kde.org>                             *
- *  Copyright 2013 Martin Gräßlin <mgraesslin@kde.org>                               *
- *                                                                                   *
- *  This library is free software; you can redistribute it and/or                    *
- *  modify it under the terms of the GNU Lesser General Public                       *
- *  License as published by the Free Software Foundation; either                     *
- *  version 2.1 of the License, or (at your option) any later version.               *
- *                                                                                   *
- *  This library is distributed in the hope that it will be useful,                  *
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of                   *
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU                *
- *  Lesser General Public License for more details.                                  *
- *                                                                                   *
- *  You should have received a copy of the GNU Lesser General Public                 *
- *  License along with this library; if not, write to the Free Software              *
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA       *
- *************************************************************************************/
+/*************************************************************************
+Copyright © 2013        Martin Gräßlin <mgraesslin@kde.org>
+Copyright © 2014-2015   Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
 #include "waylandconfig.h"
 
 #include "waylandbackend.h"
+#include "wayland_interface.h"
 #include "waylandoutput.h"
 #include "waylandscreen.h"
 
 #include "tabletmodemanager_interface.h"
+#include "wayland_logging.h"
 
-#include <configmonitor.h>
-#include <mode.h>
+#include <KPluginLoader>
+#include <KPluginMetaData>
 
-#include <KWayland/Client/connection_thread.h>
-#include <KWayland/Client/event_queue.h>
-#include <KWayland/Client/registry.h>
-#include <KWayland/Client/outputconfiguration.h>
-#include <KWayland/Client/outputmanagement.h>
-
-#include <QTimer>
-
-using namespace KScreen;
+namespace KScreen
+{
 
 WaylandConfig::WaylandConfig(QObject *parent)
     : QObject(parent)
-    , m_outputManagement(nullptr)
-    , m_registryInitialized(false)
-    , m_blockSignals(true)
     , m_kscreenConfig(new Config)
-    , m_kscreenPendingConfig(nullptr)
     , m_screen(new WaylandScreen(this))
     , m_tabletModeAvailable(false)
     , m_tabletModeEngaged(false)
 {
     initKWinTabletMode();
-
-    connect(this, &WaylandConfig::initialized, &m_syncLoop, &QEventLoop::quit);
-    QTimer::singleShot(3000, this, [this] {
-        if (m_syncLoop.isRunning()) {
-            qCWarning(KSCREEN_WAYLAND) << "Connection to Wayland server at socket:"
-                                       << m_connection->socketName() << "timed out.";
-            m_syncLoop.quit();
-            m_thread->quit();
-            m_thread->wait();
-        }
-    });
-
-    initConnection();
-    m_syncLoop.exec();
+    queryInterfaces();
 }
 
 WaylandConfig::~WaylandConfig()
 {
-    m_thread->quit();
-    m_thread->wait();
-    m_syncLoop.quit();
+    for (auto pending : m_pendingInterfaces) {
+        rejectInterface(pending);
+    }
+    m_pendingInterfaces.clear();
 }
 
 void WaylandConfig::initKWinTabletMode()
@@ -92,7 +72,7 @@ void WaylandConfig::initKWinTabletMode()
                     return;
                 }
                 m_tabletModeEngaged = tabletMode;
-                if (!m_blockSignals && m_initializingOutputs.empty()) {
+                if (m_interface && m_interface->isInitialized()) {
                     Q_EMIT configChanged();
                 }
             }
@@ -103,271 +83,132 @@ void WaylandConfig::initKWinTabletMode()
                     return;
                 }
                 m_tabletModeAvailable = available;
-                if (!m_blockSignals && m_initializingOutputs.empty()) {
+                if (m_interface && m_interface->isInitialized()) {
                     Q_EMIT configChanged();
                 }
     });
 }
 
-void WaylandConfig::initConnection()
+bool WaylandConfig::isInitialized() const
 {
-    m_thread = new QThread(this);
-    m_connection = new KWayland::Client::ConnectionThread;
-
-    connect(m_connection, &KWayland::Client::ConnectionThread::connected,
-            this, &WaylandConfig::setupRegistry, Qt::QueuedConnection);
-
-    connect(m_connection, &KWayland::Client::ConnectionThread::connectionDied,
-            this, &WaylandConfig::disconnected, Qt::QueuedConnection);
+    return m_interface && m_interface->isInitialized();
+}
 
-    connect(m_connection, &KWayland::Client::ConnectionThread::failed, this, [this] {
-        qCWarning(KSCREEN_WAYLAND) << "Failed to connect to Wayland server at socket:"
-                                   << m_connection->socketName();
-        m_syncLoop.quit();
-        m_thread->quit();
-        m_thread->wait();
-    });
+ConfigPtr WaylandConfig::currentConfig()
+{
+    // TODO: do this setScreen call less clunky
+    m_kscreenConfig->setScreen(m_screen->toKScreenScreen(m_kscreenConfig));
 
-    m_thread->start();
-    m_connection->moveToThread(m_thread);
-    m_connection->initConnection();
+    m_interface->updateConfig(m_kscreenConfig);
 
-}
+    ScreenPtr screen = m_kscreenConfig->screen();
+    m_screen->updateKScreenScreen(screen);
 
-void WaylandConfig::blockSignals()
-{
-    Q_ASSERT(m_blockSignals == false);
-    m_blockSignals = true;
+    return m_kscreenConfig;
 }
 
-void WaylandConfig::unblockSignals()
+void WaylandConfig::setScreenOutputs()
 {
-    Q_ASSERT(m_blockSignals == true);
-    m_blockSignals = false;
+    m_screen->setOutputs(outputMap().values());
 }
 
-void WaylandConfig::disconnected()
+QMap<int, WaylandOutput*> WaylandConfig::outputMap() const
 {
-    qCWarning(KSCREEN_WAYLAND) << "Wayland disconnected, cleaning up.";
-    qDeleteAll(m_outputMap);
-    m_outputMap.clear();
-
-    // Clean up
-    if (m_queue) {
-        delete m_queue;
-        m_queue = nullptr;
-    }
-
-    m_connection->deleteLater();
-    m_connection = nullptr;
-
-    if (m_thread) {
-        m_thread->quit();
-        if (!m_thread->wait(3000)) {
-            m_thread->terminate();
-            m_thread->wait();
-        }
-        delete m_thread;
-        m_thread = nullptr;
-    }
-
-    Q_EMIT configChanged();
+    return m_interface->outputMap();
 }
 
-void WaylandConfig::setupRegistry()
+void WaylandConfig::applyConfig(const ConfigPtr &newConfig)
 {
-    m_queue = new KWayland::Client::EventQueue(this);
-    m_queue->setup(m_connection);
-
-    m_registry = new KWayland::Client::Registry(this);
-
-    connect(m_registry, &KWayland::Client::Registry::outputDeviceAnnounced,
-            this, &WaylandConfig::addOutput);
-
-    connect(m_registry, &KWayland::Client::Registry::outputManagementAnnounced,
-            this, [this](quint32 name, quint32 version) {
-                m_outputManagement = m_registry->createOutputManagement(name, version, m_registry);
-                checkInitialized();
-            }
-    );
-
-    connect(m_registry, &KWayland::Client::Registry::interfacesAnnounced,
-            this, [this] {
-                m_registryInitialized = true;
-                unblockSignals();
-                checkInitialized();
-            }
-    );
-
-    m_registry->create(m_connection);
-    m_registry->setEventQueue(m_queue);
-    m_registry->setup();
+    m_interface->applyConfig(newConfig);
 }
 
-int s_outputId = 0;
-
-void WaylandConfig::addOutput(quint32 name, quint32 version)
+void WaylandConfig::queryInterfaces()
 {
-    WaylandOutput *waylandoutput = new WaylandOutput(++s_outputId, this);
-    m_initializingOutputs << waylandoutput;
-
-    connect(waylandoutput, &WaylandOutput::deviceRemoved, this, [this, waylandoutput]() {
-        removeOutput(waylandoutput);
-    });
-    waylandoutput->createOutputDevice(m_registry, name, version);
-
-    // finalize: when the output is done, we put it in the known outputs map,
-    // remove if from the list of initializing outputs, and emit configChanged()
-    connect(waylandoutput, &WaylandOutput::complete, this, [this, waylandoutput]{
-        m_outputMap.insert(waylandoutput->id(), waylandoutput);
-        m_initializingOutputs.removeOne(waylandoutput);
-        checkInitialized();
-
-        if (!m_blockSignals && m_initializingOutputs.empty()) {
-            m_screen->setOutputs(m_outputMap.values());
-            Q_EMIT configChanged();
+    QTimer::singleShot(3000, this, [this] {
+        for (auto pending : m_pendingInterfaces) {
+            qCWarning(KSCREEN_WAYLAND) << pending.name << "backend could not be aquired in time.";
+            rejectInterface(pending);
         }
-
-        connect(waylandoutput, &WaylandOutput::changed, this, [this]() {
-            if (!m_blockSignals) {
-                Q_EMIT configChanged();
-            }
-        });
+        if (m_syncLoop.isRunning()) {
+            qCWarning(KSCREEN_WAYLAND) << "Connection to Wayland server timed out. Does the "
+                                          "compositor support output management?";
+            m_syncLoop.quit();
+        }
+        m_pendingInterfaces.clear();
     });
-}
-
-void WaylandConfig::removeOutput(WaylandOutput *output)
-{
-    if (m_initializingOutputs.removeOne(output)) {
-        // output was not yet fully initialized, just remove here and return
-        delete output;
-        return;
-    }
 
-    // remove the output from output mapping
-    const auto removedOutput = m_outputMap.take(output->id());
-    Q_ASSERT(removedOutput == output); Q_UNUSED(removedOutput);
-    m_screen->setOutputs(m_outputMap.values());
-    delete output;
+    auto availableInterfacePlugins
+            = KPluginLoader::findPlugins(QStringLiteral("org.kde.libkscreen.backends/wayland"));
 
-    if (!m_blockSignals) {
-        Q_EMIT configChanged();
+    for (auto plugin : availableInterfacePlugins) {
+        queryInterface(&plugin);
     }
+    m_syncLoop.exec();
 }
 
-bool WaylandConfig::isInitialized() const
-{
-    return !m_blockSignals
-            && m_registryInitialized
-            && m_initializingOutputs.isEmpty()
-            && m_outputMap.count() > 0
-            && m_outputManagement != nullptr;
-}
-
-void WaylandConfig::checkInitialized()
+void WaylandConfig::queryInterface(KPluginMetaData *plugin)
 {
-    if (isInitialized()) {
-        m_screen->setOutputs(m_outputMap.values());
-        Q_EMIT initialized();
-    }
-}
+    PendingInterface pending;
 
-KScreen::ConfigPtr WaylandConfig::currentConfig()
-{
-    // TODO: do this setScreen call less clunky
-    m_kscreenConfig->setScreen(m_screen->toKScreenScreen(m_kscreenConfig));
+    pending.name = plugin->name();
 
-    const auto features = Config::Feature::Writable | Config::Feature::PerOutputScaling
-                        | Config::Feature::AutoRotation | Config::Feature::TabletMode;
-    m_kscreenConfig->setSupportedFeatures(features);
-    m_kscreenConfig->setValid(m_connection->display());
-
-    KScreen::ScreenPtr screen = m_kscreenConfig->screen();
-    m_screen->updateKScreenScreen(screen);
-
-    //Removing removed outputs
-    const KScreen::OutputList outputs = m_kscreenConfig->outputs();
-    for (const auto &output : outputs) {
-        if (!m_outputMap.contains(output->id())) {
-            m_kscreenConfig->removeOutput(output->id());
-        }
+    // TODO: qobject_cast not working here. Why?
+    auto *factory = dynamic_cast<WaylandFactory*>(plugin->instantiate());
+    if (!factory) {
+        return;
     }
+    pending.interface = factory->createInterface(this);
+    pending.thread = new QThread(this);
+
+    m_pendingInterfaces.push_back(pending);
+    connect(pending.interface, &WaylandInterface::connectionFailed, this, [this, &pending] {
+        qCWarning(KSCREEN_WAYLAND) << "Backend" << pending.name << "failed.";
+        rejectInterface(pending);
+        m_pendingInterfaces.erase(std::remove(m_pendingInterfaces.begin(),
+                                              m_pendingInterfaces.end(), pending),
+                                  m_pendingInterfaces.end());
+    });
 
-    // Add KScreen::Outputs that aren't in the list yet, handle primaryOutput
-    KScreen::OutputList kscreenOutputs = m_kscreenConfig->outputs();
-    for (const auto &output : m_outputMap) {
-        KScreen::OutputPtr kscreenOutput = kscreenOutputs[output->id()];
-        if (!kscreenOutput) {
-            kscreenOutput = output->toKScreenOutput();
-            kscreenOutputs.insert(kscreenOutput->id(), kscreenOutput);
+    connect(pending.interface, &WaylandInterface::initialized, this, [this, pending] {
+        if (m_interface) {
+            // Too late. Already have an interface initialized.
+            return;
         }
-        if (kscreenOutput && m_outputMap.count() == 1) {
-            kscreenOutput->setPrimary(true);
-        } else if (m_outputMap.count() > 1) {
-            // primaryScreen concept doesn't exist in kwayland, so we don't set one
+
+        for (auto other : m_pendingInterfaces) {
+            if (other.interface != pending.interface) {
+                rejectInterface(other);
+            }
         }
-        output->updateKScreenOutput(kscreenOutput);
-    }
-    m_kscreenConfig->setOutputs(kscreenOutputs);
+        m_pendingInterfaces.clear();
 
-    m_kscreenConfig->setTabletModeAvailable(m_tabletModeAvailable);
-    m_kscreenConfig->setTabletModeEngaged(m_tabletModeEngaged);
+        takeInterface(pending);
+        m_syncLoop.quit();
+    });
 
-    return m_kscreenConfig;
+    pending.interface->initConnection(pending.thread);
 }
 
-QMap<int, WaylandOutput*> WaylandConfig::outputMap() const
+void WaylandConfig::takeInterface(const PendingInterface &pending)
 {
-    return m_outputMap;
-}
+    m_interface = pending.interface;
+    connect(m_interface, &WaylandInterface::configChanged, this, &WaylandConfig::configChanged);
 
-void WaylandConfig::tryPendingConfig()
-{
-    if (!m_kscreenPendingConfig) {
-        return;
-    }
-    applyConfig(m_kscreenPendingConfig);
-    m_kscreenPendingConfig = nullptr;
+    setScreenOutputs();
+    connect(m_interface, &WaylandInterface::outputsChanged, this, &WaylandConfig::setScreenOutputs);
+
+    qCDebug(KSCREEN_WAYLAND) << "Backend" << pending.name << "initialized.";
+    Q_EMIT initialized();
 }
 
-void WaylandConfig::applyConfig(const KScreen::ConfigPtr &newConfig)
+void WaylandConfig::rejectInterface(const PendingInterface &pending)
 {
-    using namespace KWayland::Client;
-    // Create a new configuration object
-    auto wlConfig = m_outputManagement->createConfiguration();
-    bool changed = false;
-
-    if (m_blockSignals) {
-        /* Last apply still pending, remember new changes and apply afterwards */
-        m_kscreenPendingConfig = newConfig;
-        return;
-    }
+    pending.thread->quit();
+    pending.thread->wait();
+    delete pending.thread;
+    delete pending.interface;
 
-    for (const auto &output : newConfig->outputs()) {
-        changed |= m_outputMap[output->id()]->setWlConfig(wlConfig, output);
-    }
-
-    if (!changed) {
-        return;
-    }
-
-    // We now block changes in order to compress events while the compositor is doing its thing
-    // once it's done or failed, we'll trigger configChanged() only once, and not per individual
-    // property change.
-    connect(wlConfig, &OutputConfiguration::applied, this, [this, wlConfig] {
-        wlConfig->deleteLater();
-        unblockSignals();
-        Q_EMIT configChanged();
-        tryPendingConfig();
-    });
-    connect(wlConfig, &OutputConfiguration::failed, this, [this, wlConfig] {
-        wlConfig->deleteLater();
-        unblockSignals();
-        Q_EMIT configChanged();
-        tryPendingConfig();
-    });
+    qCDebug(KSCREEN_WAYLAND) << "Backend" << pending.name << "rejected.";
+}
 
-    // Now block signals and ask the compositor to apply the changes.
-    blockSignals();
-    wlConfig->apply();
 }
diff --git a/backends/kwayland/waylandconfig.h b/backends/kwayland/waylandconfig.h
index 0986bc4..e8ecd97 100644
--- a/backends/kwayland/waylandconfig.h
+++ b/backends/kwayland/waylandconfig.h
@@ -1,47 +1,37 @@
-/*************************************************************************************
- *  Copyright 2014-2015 Sebastian Kügler <sebas@kde.org>                             *
- *                                                                                   *
- *  This library is free software; you can redistribute it and/or                    *
- *  modify it under the terms of the GNU Lesser General Public                       *
- *  License as published by the Free Software Foundation; either                     *
- *  version 2.1 of the License, or (at your option) any later version.               *
- *                                                                                   *
- *  This library is distributed in the hope that it will be useful,                  *
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of                   *
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU                *
- *  Lesser General Public License for more details.                                  *
- *                                                                                   *
- *  You should have received a copy of the GNU Lesser General Public                 *
- *  License along with this library; if not, write to the Free Software              *
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA       *
- *************************************************************************************/
+/*************************************************************************
+Copyright © 2014-2015 Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
 #pragma once
 
 #include "abstractbackend.h"
 #include "config.h"
 
-#include <QDir>
 #include <QEventLoop>
-#include <QLoggingCategory>
-#include <QSize>
-#include <QScreen>
-#include <QSocketNotifier>
-#include <QThread>
+#include <QPointer>
 
-namespace KWayland
-{
-namespace Client
-{
-class ConnectionThread;
-class EventQueue;
-class Registry;
-class OutputManagement;
-}
-}
+#include <vector>
+
+class KPluginMetaData;
 
 namespace KScreen
 {
 class Output;
+class WaylandInterface;
 class WaylandOutput;
 class WaylandScreen;
 
@@ -66,8 +56,8 @@ public:
     explicit WaylandConfig(QObject *parent = nullptr);
     ~WaylandConfig() override;
 
-    KScreen::ConfigPtr currentConfig();
-    QMap<int, WaylandOutput*> outputMap() const;
+    virtual KScreen::ConfigPtr currentConfig();
+    virtual QMap<int, WaylandOutput*> outputMap() const;
 
     void applyConfig(const KScreen::ConfigPtr &newConfig);
 
@@ -78,43 +68,33 @@ Q_SIGNALS:
     void initialized();
 
 private:
-    void setupRegistry();
-    void checkInitialized();
-    void disconnected();
+    struct PendingInterface {
+        bool operator ==(const PendingInterface &other) {
+            return name == other.name;
+        }
+        QString name;
+        WaylandInterface *interface;
+        QThread *thread;
+    };
 
     void initKWinTabletMode();
-    void initConnection();
-
-    void addOutput(quint32 name, quint32 version);
-    void removeOutput(WaylandOutput *output);
-
-    void blockSignals();
-    void unblockSignals();
-    void tryPendingConfig();
+    void setScreenOutputs();
 
-    KWayland::Client::ConnectionThread *m_connection;
-    KWayland::Client::EventQueue *m_queue;
-    QThread *m_thread;
+    void queryInterfaces();
+    void queryInterface(KPluginMetaData *plugin);
+    void takeInterface(const PendingInterface &pending);
+    void rejectInterface(const PendingInterface &pending);
 
-    KWayland::Client::Registry *m_registry;
-    KWayland::Client::OutputManagement *m_outputManagement;
-
-    // KWayland names as keys
-    QMap<int, WaylandOutput*> m_outputMap;
-
-    // KWayland names
-    QList<WaylandOutput*> m_initializingOutputs;
-    int m_lastOutputId = -1;
-
-    bool m_registryInitialized;
-    bool m_blockSignals;
-    QEventLoop m_syncLoop;
     KScreen::ConfigPtr m_kscreenConfig;
-    KScreen::ConfigPtr m_kscreenPendingConfig;
     WaylandScreen *m_screen;
+    QPointer<WaylandInterface> m_interface;
 
     bool m_tabletModeAvailable;
     bool m_tabletModeEngaged;
+
+    QEventLoop m_syncLoop;
+
+    std::vector<PendingInterface> m_pendingInterfaces;
 };
 
 }
diff --git a/backends/kwayland/waylandoutput.cpp b/backends/kwayland/waylandoutput.cpp
index 18a9de8..1e848c7 100644
--- a/backends/kwayland/waylandoutput.cpp
+++ b/backends/kwayland/waylandoutput.cpp
@@ -1,20 +1,21 @@
-/*************************************************************************************
- *  Copyright 2014-2015 Sebastian Kügler <sebas@kde.org>                             *
- *                                                                                   *
- *  This library is free software; you can redistribute it and/or                    *
- *  modify it under the terms of the GNU Lesser General Public                       *
- *  License as published by the Free Software Foundation; either                     *
- *  version 2.1 of the License, or (at your option) any later version.               *
- *                                                                                   *
- *  This library is distributed in the hope that it will be useful,                  *
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of                   *
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU                *
- *  Lesser General Public License for more details.                                  *
- *                                                                                   *
- *  You should have received a copy of the GNU Lesser General Public                 *
- *  License along with this library; if not, write to the Free Software              *
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA       *
- *************************************************************************************/
+/*************************************************************************
+Copyright © 2014-2015 Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
 #include "waylandoutput.h"
 #include "waylandbackend.h"
 #include "waylandconfig.h"
@@ -23,70 +24,19 @@
 #include <mode.h>
 #include <edid.h>
 
-#include <KWayland/Client/outputconfiguration.h>
-#include <KWayland/Client/outputdevice.h>
-
 using namespace KScreen;
-namespace Wl = KWayland::Client;
-
-const QMap<Wl::OutputDevice::Transform, Output::Rotation>
-s_rotationMap = {
-    {Wl::OutputDevice::Transform::Normal, Output::None},
-    {Wl::OutputDevice::Transform::Rotated90, Output::Right},
-    {Wl::OutputDevice::Transform::Rotated180, Output::Inverted},
-    {Wl::OutputDevice::Transform::Rotated270, Output::Left},
-    {Wl::OutputDevice::Transform::Flipped, Output::None},
-    {Wl::OutputDevice::Transform::Flipped90, Output::Right},
-    {Wl::OutputDevice::Transform::Flipped180, Output::Inverted},
-    {Wl::OutputDevice::Transform::Flipped270, Output::Left}
-};
-
-Output::Rotation toKScreenRotation(const Wl::OutputDevice::Transform transform)
-{
-    auto it = s_rotationMap.constFind(transform);
-    return it.value();
-}
-
-Wl::OutputDevice::Transform toKWaylandTransform(const Output::Rotation rotation)
-{
-    return s_rotationMap.key(rotation);
-}
 
-WaylandOutput::WaylandOutput(quint32 id, WaylandConfig *parent)
+WaylandOutput::WaylandOutput(quint32 id, QObject *parent)
     : QObject(parent)
     , m_id(id)
-    , m_device(nullptr)
 {
 }
 
 quint32 WaylandOutput::id() const
 {
-    Q_ASSERT(m_device);
     return m_id;
 }
 
-bool WaylandOutput::enabled() const
-{
-    return m_device != nullptr;
-}
-
-Wl::OutputDevice* WaylandOutput::outputDevice() const
-{
-    return m_device;
-}
-
-void WaylandOutput::createOutputDevice(Wl::Registry *registry, quint32 name, quint32 version)
-{
-    Q_ASSERT(!m_device);
-    m_device = registry->createOutputDevice(name, version);
-
-    connect(m_device, &Wl::OutputDevice::removed, this, &WaylandOutput::deviceRemoved);
-    connect(m_device, &Wl::OutputDevice::done, this, [this]() {
-                Q_EMIT complete();
-                connect(m_device, &Wl::OutputDevice::changed, this, &WaylandOutput::changed);
-    });
-}
-
 OutputPtr WaylandOutput::toKScreenOutput()
 {
     OutputPtr output(new Output());
@@ -94,132 +44,3 @@ OutputPtr WaylandOutput::toKScreenOutput()
     updateKScreenOutput(output);
     return output;
 }
-
-void WaylandOutput::updateKScreenOutput(OutputPtr &output)
-{
-    // Initialize primary output
-    output->setId(m_id);
-    output->setEnabled(m_device->enabled() == Wl::OutputDevice::Enablement::Enabled);
-    output->setConnected(true);
-    output->setPrimary(true); // FIXME: wayland doesn't have the concept of a primary display
-    output->setName(name());
-    output->setSizeMm(m_device->physicalSize());
-    output->setPos(m_device->globalPosition());
-    output->setRotation(s_rotationMap[m_device->transform()]);
-
-    ModeList modeList;
-    QStringList preferredModeIds;
-    m_modeIdMap.clear();
-    QString currentModeId = QStringLiteral("-1");
-
-    for (const Wl::OutputDevice::Mode &wlMode : m_device->modes()) {
-        ModePtr mode(new Mode());
-        const QString name = modeName(wlMode);
-
-        QString modeId = QString::number(wlMode.id);
-        if (modeId.isEmpty()) {
-            qCDebug(KSCREEN_WAYLAND) << "Could not create mode id from"
-                                     << wlMode.id << ", using" << name << "instead.";
-            modeId = name;
-        }
-
-        if (m_modeIdMap.contains(modeId)) {
-            qCWarning(KSCREEN_WAYLAND) << "Mode id already in use:" << modeId;
-        }
-        mode->setId(modeId);
-
-        // KWayland gives the refresh rate as int in mHz
-        mode->setRefreshRate(wlMode.refreshRate / 1000.0);
-        mode->setSize(wlMode.size);
-        mode->setName(name);
-
-        if (wlMode.flags.testFlag(Wl::OutputDevice::Mode::Flag::Current)) {
-            currentModeId = modeId;
-        }
-        if (wlMode.flags.testFlag(Wl::OutputDevice::Mode::Flag::Preferred)) {
-            preferredModeIds << modeId;
-        }
-
-        // Update the kscreen => kwayland mode id translation map
-        m_modeIdMap.insert(modeId, wlMode.id);
-        // Add to the modelist which gets set on the output
-        modeList[modeId] = mode;
-    }
-
-    if (currentModeId == QLatin1String("-1")) {
-        qCWarning(KSCREEN_WAYLAND) << "Could not find the current mode id" << modeList;
-    }
-
-    output->setCurrentModeId(currentModeId);
-    output->setPreferredModes(preferredModeIds);
-    output->setModes(modeList);
-    output->setScale(m_device->scaleF());
-    output->setType(Utils::guessOutputType(m_device->model(), m_device->model()));
-}
-
-bool WaylandOutput::setWlConfig(Wl::OutputConfiguration *wlConfig,
-                                const KScreen::OutputPtr &output)
-{
-    bool changed = false;
-
-    // enabled?
-    if ((m_device->enabled() == Wl::OutputDevice::Enablement::Enabled)
-            != output->isEnabled()) {
-        changed = true;
-        const auto enablement = output->isEnabled() ? Wl::OutputDevice::Enablement::Enabled :
-                                                      Wl::OutputDevice::Enablement::Disabled;
-        wlConfig->setEnabled(m_device, enablement);
-    }
-
-    // position
-    if (m_device->globalPosition() != output->pos()) {
-        changed = true;
-        wlConfig->setPosition(m_device, output->pos());
-    }
-
-    // scale
-    if (!qFuzzyCompare(m_device->scaleF(), output->scale())) {
-        changed = true;
-        wlConfig->setScaleF(m_device, output->scale());
-    }
-
-    // rotation
-    if (toKScreenRotation(m_device->transform()) != output->rotation()) {
-        changed = true;
-        wlConfig->setTransform(m_device, toKWaylandTransform(output->rotation()));
-    }
-
-    // mode
-    if (m_modeIdMap.contains(output->currentModeId())) {
-        const int newModeId = m_modeIdMap.value(output->currentModeId(), -1);
-        if (newModeId != m_device->currentMode().id) {
-            changed = true;
-            wlConfig->setMode(m_device, newModeId);
-        }
-    } else {
-        qCWarning(KSCREEN_WAYLAND) << "Invalid kscreen mode id:" << output->currentModeId()
-                                   << "\n\n" << m_modeIdMap;
-    }
-    return changed;
-}
-
-QString WaylandOutput::modeName(const Wl::OutputDevice::Mode &m) const
-{
-    return QString::number(m.size.width()) + QLatin1Char('x') +
-           QString::number(m.size.height()) + QLatin1Char('@') +
-           QString::number(qRound(m.refreshRate/1000.0));
-}
-
-QString WaylandOutput::name() const
-{
-    Q_ASSERT(m_device);
-    return QStringLiteral("%1 %2").arg(m_device->manufacturer(), m_device->model());
-}
-
-QDebug operator<<(QDebug dbg, const WaylandOutput *output)
-{
-    dbg << "WaylandOutput(Id:" << output->id() <<", Name:" << \
-        QString(output->outputDevice()->manufacturer() + QLatin1Char(' ') + \
-        output->outputDevice()->model())  << ")";
-    return dbg;
-}
diff --git a/backends/kwayland/waylandoutput.h b/backends/kwayland/waylandoutput.h
index c1b5de3..6ee6623 100644
--- a/backends/kwayland/waylandoutput.h
+++ b/backends/kwayland/waylandoutput.h
@@ -1,85 +1,61 @@
-/*************************************************************************************
- *  Copyright 2014-2015 Sebastian Kügler <sebas@kde.org>                             *
- *                                                                                   *
- *  This library is free software; you can redistribute it and/or                    *
- *  modify it under the terms of the GNU Lesser General Public                       *
- *  License as published by the Free Software Foundation; either                     *
- *  version 2.1 of the License, or (at your option) any later version.               *
- *                                                                                   *
- *  This library is distributed in the hope that it will be useful,                  *
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of                   *
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU                *
- *  Lesser General Public License for more details.                                  *
- *                                                                                   *
- *  You should have received a copy of the GNU Lesser General Public                 *
- *  License along with this library; if not, write to the Free Software              *
- *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA       *
- *************************************************************************************/
+/*************************************************************************
+Copyright © 2014-2015 Sebastian Kügler <sebas@kde.org>
+Copyright © 2019-2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
 #pragma once
 
-#include "waylandconfig.h"
-
-#include "abstractbackend.h"
 #include "output.h"
 
-#include <KWayland/Client/outputdevice.h>
-#include <KWayland/Client/registry.h>
-
 #include <QLoggingCategory>
 #include <QScreen>
 #include <QSize>
 
-namespace KWayland
-{
-namespace Client
-{
-class OutputConfiguration;
-}
-}
-
 namespace KScreen
 {
+class WaylandInterface;
 
 class WaylandOutput : public QObject
 {
     Q_OBJECT
 
 public:
-    explicit WaylandOutput(quint32 id, WaylandConfig *parent = nullptr);
+    explicit WaylandOutput(quint32 id, QObject *parent = nullptr);
     ~WaylandOutput() override = default;
 
     KScreen::OutputPtr toKScreenOutput();
-    void updateKScreenOutput(KScreen::OutputPtr &output);
-
-    quint32 id() const;
-    QString name() const;
-    bool enabled() const;
-
-    KWayland::Client::OutputDevice* outputDevice() const;
-    void createOutputDevice(KWayland::Client::Registry *registry, quint32 name, quint32 version);
+    virtual void updateKScreenOutput(KScreen::OutputPtr &output) = 0;
 
-    bool setWlConfig(KWayland::Client::OutputConfiguration *wlConfig,
-                   const KScreen::OutputPtr &output);
+    virtual quint32 id() const;
+    virtual QByteArray edid() const = 0;
+    virtual bool enabled() const = 0;
+    virtual QRectF geometry() const = 0;
 
 Q_SIGNALS:
-    void deviceRemoved();
-
-    void complete();
-    // only emitted after complete signal
+    void dataReceived();
     void changed();
+    void removed();
 
 private:
     void showOutput();
-    QString modeName(const KWayland::Client::OutputDevice::Mode &m) const;
 
     quint32 m_id;
-    KWayland::Client::OutputDevice *m_device;
-    KWayland::Client::Registry *m_registry;
 
-    // left-hand-side: KScreen::Mode, right-hand-side: KWayland's mode.id
+    // left-hand-side: KScreen::Mode, right-hand-side: Compositor's mode id
     QMap<QString, int> m_modeIdMap;
 };
 
 }
-
-KSCREEN_EXPORT QDebug operator<<(QDebug dbg, const KScreen::WaylandOutput *output);
diff --git a/backends/kwayland/waylandscreen.cpp b/backends/kwayland/waylandscreen.cpp
index c8f2ac4..e642368 100644
--- a/backends/kwayland/waylandscreen.cpp
+++ b/backends/kwayland/waylandscreen.cpp
@@ -46,8 +46,7 @@ void WaylandScreen::setOutputs(const QList<WaylandOutput*> &outputs)
     QRect r;
     for (const auto *out : outputs) {
         if (out->enabled()) {
-            const auto *dev = out->outputDevice();
-            r |= QRect(dev->globalPosition(), dev->pixelSize() / dev->scale());
+            r |= out->geometry().toRect();
         }
     }
     m_size = r.size();
-- 
2.26.1


From 5951c6c09064f7a2e34435334501a86b2dc35fbf Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 6 Jan 2020 15:57:13 +0100
Subject: [PATCH 2/3] feat(wayland): add Wrapland plugin

Adds a plugin that uses the Wrapland library to interact with compositors
supporting the kwinft_output_management_unstable_v1 protocol.

If the backend plugin is available at runtime the interface is instantiated in
parallel with the KWayland interface and whichever interface has success in
retrieving a management global first is used while the other one is deleted.
---
 backends/kwayland/plugins/CMakeLists.txt      |  10 +
 .../kwayland/plugins/wrapland/CMakeLists.txt  |  29 +++
 .../kwayland/plugins/wrapland/wrapland.json   |   7 +
 .../plugins/wrapland/wrapland_interface.cpp   | 243 ++++++++++++++++++
 .../plugins/wrapland/wrapland_interface.h     |  95 +++++++
 .../plugins/wrapland/wrapland_output.cpp      | 233 +++++++++++++++++
 .../plugins/wrapland/wrapland_output.h        |  70 +++++
 backends/kwayland/wayland_interface.cpp       |   2 +-
 backends/kwayland/wayland_interface.h         |   1 +
 9 files changed, 689 insertions(+), 1 deletion(-)
 create mode 100644 backends/kwayland/plugins/wrapland/CMakeLists.txt
 create mode 100644 backends/kwayland/plugins/wrapland/wrapland.json
 create mode 100644 backends/kwayland/plugins/wrapland/wrapland_interface.cpp
 create mode 100644 backends/kwayland/plugins/wrapland/wrapland_interface.h
 create mode 100644 backends/kwayland/plugins/wrapland/wrapland_output.cpp
 create mode 100644 backends/kwayland/plugins/wrapland/wrapland_output.h

diff --git a/backends/kwayland/plugins/CMakeLists.txt b/backends/kwayland/plugins/CMakeLists.txt
index 77c3628..720efa1 100644
--- a/backends/kwayland/plugins/CMakeLists.txt
+++ b/backends/kwayland/plugins/CMakeLists.txt
@@ -1 +1,11 @@
 add_subdirectory(kwayland)
+
+find_package(Wrapland CONFIG)
+set_package_properties(Wrapland PROPERTIES
+    TYPE OPTIONAL
+    PURPOSE "Used as Wrapper library for Wayland protocol objects."
+)
+
+if (Wrapland_FOUND)
+    add_subdirectory(wrapland)
+endif()
diff --git a/backends/kwayland/plugins/wrapland/CMakeLists.txt b/backends/kwayland/plugins/wrapland/CMakeLists.txt
new file mode 100644
index 0000000..ec624a0
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/CMakeLists.txt
@@ -0,0 +1,29 @@
+set(wrapland_SRCS
+    wrapland_interface.cpp
+    wrapland_output.cpp
+    ../../wayland_interface.cpp
+    ../../waylandoutput.cpp
+    ../../wayland_logging.cpp
+    ../../../utils.cpp
+)
+
+include_directories(${CMAKE_SOURCE_DIR}/backends/kwayland)
+
+add_library(LibkscreenWaylandPluginWrapland MODULE ${wrapland_SRCS})
+
+set_target_properties(LibkscreenWaylandPluginWrapland
+    PROPERTIES LIBRARY_OUTPUT_DIRECTORY
+    "${CMAKE_BINARY_DIR}/bin/org.kde.libkscreen.backends/wayland/"
+)
+
+target_link_libraries(LibkscreenWaylandPluginWrapland
+    Qt5::Core
+    Qt5::Gui
+    KF5::Screen
+    WraplandClient
+)
+
+install(
+    TARGETS LibkscreenWaylandPluginWrapland
+    DESTINATION ${PLUGIN_INSTALL_DIR}/org.kde.libkscreen.backends/wayland/
+)
diff --git a/backends/kwayland/plugins/wrapland/wrapland.json b/backends/kwayland/plugins/wrapland/wrapland.json
new file mode 100644
index 0000000..5283a23
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/wrapland.json
@@ -0,0 +1,7 @@
+{
+    "KPlugin": {
+        "Description": "Wayland backend using Wrapland library's output management interface.",
+        "Id": "LibkscreenWaylandPluginWrapland",
+        "Name": "wrapland"
+    }
+}
diff --git a/backends/kwayland/plugins/wrapland/wrapland_interface.cpp b/backends/kwayland/plugins/wrapland/wrapland_interface.cpp
new file mode 100644
index 0000000..156fa59
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/wrapland_interface.cpp
@@ -0,0 +1,243 @@
+/*************************************************************************
+Copyright © 2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "wrapland_interface.h"
+
+#include "waylandbackend.h"
+#include "wrapland_output.h"
+#include "waylandscreen.h"
+
+#include "../../wayland_logging.h"
+
+#include <Wrapland/Client/connection_thread.h>
+#include <Wrapland/Client/event_queue.h>
+#include <Wrapland/Client/registry.h>
+#include <Wrapland/Client/output_configuration_v1.h>
+#include <Wrapland/Client/output_management_v1.h>
+
+#include <QThread>
+
+using namespace KScreen;
+
+WaylandInterface* WraplandFactory::createInterface(QObject *parent)
+{
+    return new WraplandInterface(parent);
+}
+
+WraplandInterface::WraplandInterface(QObject *parent)
+    : WaylandInterface(parent)
+    , m_outputManagement(nullptr)
+    , m_registryInitialized(false)
+    , m_kscreenPendingConfig(nullptr)
+{
+}
+
+void WraplandInterface::initConnection(QThread *thread)
+{
+    m_connection = new Wrapland::Client::ConnectionThread;
+
+    connect(m_connection, &Wrapland::Client::ConnectionThread::establishedChanged,
+            this, [this](bool established) {
+            if (established) {
+                setupRegistry();
+            } else {
+                handleDisconnect();
+            }
+     }, Qt::QueuedConnection);
+
+    connect(m_connection, &Wrapland::Client::ConnectionThread::failed, this, [this] {
+        qCWarning(KSCREEN_WAYLAND) << "Failed to connect to Wayland server at socket:"
+                                   << m_connection->socketName();
+        Q_EMIT connectionFailed(m_connection->socketName());
+    });
+
+    thread->start();
+    m_connection->moveToThread(thread);
+    m_connection->establishConnection();
+}
+
+bool WraplandInterface::isInitialized() const
+{
+    return m_registryInitialized && m_outputManagement != nullptr
+            && WaylandInterface::isInitialized();
+}
+
+void WraplandInterface::handleDisconnect()
+{
+    qDeleteAll(m_outputMap);
+    m_outputMap.clear();
+
+    // Clean up
+    if (m_queue) {
+        delete m_queue;
+        m_queue = nullptr;
+    }
+
+    m_connection->deleteLater();
+    m_connection = nullptr;
+
+    WaylandInterface::handleDisconnect();
+}
+
+void WraplandInterface::setupRegistry()
+{
+    m_queue = new Wrapland::Client::EventQueue(this);
+    m_queue->setup(m_connection);
+
+    m_registry = new Wrapland::Client::Registry(this);
+
+    connect(m_registry, &Wrapland::Client::Registry::outputDeviceV1Announced,
+            this, &WraplandInterface::addOutputDevice);
+
+    connect(m_registry, &Wrapland::Client::Registry::outputManagementV1Announced,
+            this, [this](quint32 name, quint32 version) {
+                m_outputManagement = m_registry->createOutputManagementV1(name, version,
+                                                                          m_registry);
+                m_outputManagement->setEventQueue(m_queue);
+            }
+    );
+
+    connect(m_registry, &Wrapland::Client::Registry::interfacesAnnounced,
+            this, [this] {
+                m_registryInitialized = true;
+                unblockSignals();
+                checkInitialized();
+            }
+    );
+
+    m_registry->create(m_connection);
+    m_registry->setEventQueue(m_queue);
+    m_registry->setup();
+}
+
+void WraplandInterface::addOutputDevice(quint32 name, quint32 version)
+{
+    WraplandOutput *output = new WraplandOutput(++m_outputId, this);
+    output->createOutputDevice(m_registry, name, version);
+    addOutput(output);
+}
+
+void WraplandInterface::insertOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<WraplandOutput*>(output);
+    m_outputMap.insert(out->id(), out);
+}
+
+WaylandOutput* WraplandInterface::takeOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<WraplandOutput*>(output);
+    return m_outputMap.take(out->id());
+}
+
+void WraplandInterface::updateConfig(KScreen::ConfigPtr &config)
+{
+    config->setSupportedFeatures(Config::Feature::Writable | Config::Feature::PerOutputScaling
+                                 | Config::Feature::OutputReplication
+                                 | Config::Feature::AutoRotation | Config::Feature::TabletMode);
+    config->setValid(m_connection->display());
+
+    //Removing removed outputs
+    const KScreen::OutputList outputs = config->outputs();
+    for (const auto &output : outputs) {
+        if (!m_outputMap.contains(output->id())) {
+            config->removeOutput(output->id());
+        }
+    }
+
+    // Add KScreen::Outputs that aren't in the list yet, handle primaryOutput
+    KScreen::OutputList kscreenOutputs = config->outputs();
+    for (const auto &output : m_outputMap) {
+        KScreen::OutputPtr kscreenOutput = kscreenOutputs[output->id()];
+        if (!kscreenOutput) {
+            kscreenOutput = output->toKScreenOutput();
+            kscreenOutputs.insert(kscreenOutput->id(), kscreenOutput);
+        }
+        if (kscreenOutput && m_outputMap.count() == 1) {
+            kscreenOutput->setPrimary(true);
+        } else if (m_outputMap.count() > 1) {
+            // primaryScreen concept doesn't exist in Wayland, so we don't set one
+        }
+        output->updateKScreenOutput(kscreenOutput);
+    }
+    config->setOutputs(kscreenOutputs);
+}
+
+QMap<int, WaylandOutput*> WraplandInterface::outputMap() const
+{
+    QMap<int, WaylandOutput*> ret;
+
+    auto it = m_outputMap.constBegin();
+    while (it != m_outputMap.constEnd()) {
+        ret[it.key()] = it.value();
+        ++it;
+    }
+    return ret;
+}
+
+void WraplandInterface::tryPendingConfig()
+{
+    if (!m_kscreenPendingConfig) {
+        return;
+    }
+    applyConfig(m_kscreenPendingConfig);
+    m_kscreenPendingConfig = nullptr;
+}
+
+void WraplandInterface::applyConfig(const KScreen::ConfigPtr &newConfig)
+{
+    using namespace Wrapland::Client;
+
+    // Create a new configuration object
+    auto *wlConfig = m_outputManagement->createConfiguration();
+    wlConfig->setEventQueue(m_queue);
+
+    bool changed = false;
+
+    if (signalsBlocked()) {
+        /* Last apply still pending, remember new changes and apply afterwards */
+        m_kscreenPendingConfig = newConfig;
+        return;
+    }
+
+    for (const auto &output : newConfig->outputs()) {
+        changed |= m_outputMap[output->id()]->setWlConfig(wlConfig, output);
+    }
+
+    if (!changed) {
+        return;
+    }
+
+    // We now block changes in order to compress events while the compositor is doing its thing
+    // once it's done or failed, we'll trigger configChanged() only once, and not per individual
+    // property change.
+    connect(wlConfig, &OutputConfigurationV1::applied, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+    connect(wlConfig, &OutputConfigurationV1::failed, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+
+    // Now block signals and ask the compositor to apply the changes.
+    blockSignals();
+    wlConfig->apply();
+}
diff --git a/backends/kwayland/plugins/wrapland/wrapland_interface.h b/backends/kwayland/plugins/wrapland/wrapland_interface.h
new file mode 100644
index 0000000..fed5266
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/wrapland_interface.h
@@ -0,0 +1,95 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "wayland_interface.h"
+#include "config.h"
+
+namespace Wrapland
+{
+namespace Client
+{
+class ConnectionThread;
+class EventQueue;
+class Registry;
+class OutputManagementV1;
+}
+}
+
+namespace KScreen
+{
+class Output;
+class WraplandOutput;
+class WaylandOutput;
+class WaylandScreen;
+
+class WraplandFactory : public WaylandFactory
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.kde.libkscreen.waylandinterface" FILE "wrapland.json")
+
+public:
+    WaylandInterface* createInterface(QObject *parent = nullptr) override;
+};
+
+class WraplandInterface : public WaylandInterface
+{
+    Q_OBJECT
+
+public:
+    explicit WraplandInterface(QObject *parent = nullptr);
+    ~WraplandInterface() override = default;
+
+    void initConnection(QThread *thread) override;
+    bool isInitialized() const override;
+
+    QMap<int, WaylandOutput*> outputMap() const override;
+
+    void applyConfig(const KScreen::ConfigPtr &newConfig) override;
+    void updateConfig(KScreen::ConfigPtr &config) override;
+
+protected:
+    void insertOutput(WaylandOutput *output) override;
+    WaylandOutput* takeOutput(WaylandOutput *output) override;
+    void handleDisconnect() override;
+
+private:
+    void setupRegistry();
+    void addOutputDevice(quint32 name, quint32 version);
+    void tryPendingConfig();
+
+    Wrapland::Client::ConnectionThread *m_connection;
+    Wrapland::Client::EventQueue *m_queue;
+
+    Wrapland::Client::Registry *m_registry;
+    Wrapland::Client::OutputManagementV1 *m_outputManagement;
+
+    // Wrapland names as keys
+    QMap<int, WraplandOutput*> m_outputMap;
+
+    // Wrapland names
+    int m_lastOutputId = -1;
+
+    bool m_registryInitialized;
+    bool m_blockSignals;
+    KScreen::ConfigPtr m_kscreenPendingConfig;
+
+    int m_outputId = 0;
+};
+
+}
diff --git a/backends/kwayland/plugins/wrapland/wrapland_output.cpp b/backends/kwayland/plugins/wrapland/wrapland_output.cpp
new file mode 100644
index 0000000..12c511a
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/wrapland_output.cpp
@@ -0,0 +1,233 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "wrapland_output.h"
+
+#include "waylandbackend.h"
+#include "waylandconfig.h"
+#include "../utils.h"
+
+#include <mode.h>
+#include <edid.h>
+
+#include "../../wayland_logging.h"
+
+#include <Wrapland/Client/output_configuration_v1.h>
+#include <Wrapland/Client/output_device_v1.h>
+
+using namespace KScreen;
+namespace Wl = Wrapland::Client;
+
+const QMap<Wl::OutputDeviceV1::Transform, Output::Rotation>
+s_rotationMap = {
+    {Wl::OutputDeviceV1::Transform::Normal, Output::None},
+    {Wl::OutputDeviceV1::Transform::Rotated90, Output::Right},
+    {Wl::OutputDeviceV1::Transform::Rotated180, Output::Inverted},
+    {Wl::OutputDeviceV1::Transform::Rotated270, Output::Left},
+    {Wl::OutputDeviceV1::Transform::Flipped, Output::None},
+    {Wl::OutputDeviceV1::Transform::Flipped90, Output::Right},
+    {Wl::OutputDeviceV1::Transform::Flipped180, Output::Inverted},
+    {Wl::OutputDeviceV1::Transform::Flipped270, Output::Left}
+};
+
+Output::Rotation toKScreenRotation(const Wl::OutputDeviceV1::Transform transform)
+{
+    auto it = s_rotationMap.constFind(transform);
+    return it.value();
+}
+
+Wl::OutputDeviceV1::Transform toWraplandTransform(const Output::Rotation rotation)
+{
+    return s_rotationMap.key(rotation);
+}
+
+WraplandOutput::WraplandOutput(quint32 id, QObject *parent)
+    : WaylandOutput(id, parent)
+    , m_device(nullptr)
+{
+}
+
+bool WraplandOutput::enabled() const
+{
+    return m_device != nullptr;
+}
+
+QByteArray WraplandOutput::edid() const
+{
+    return m_device->edid();
+}
+
+QRectF WraplandOutput::geometry() const
+{
+    return m_device->geometry();
+}
+
+Wrapland::Client::OutputDeviceV1 *WraplandOutput::outputDevice() const
+{
+    return m_device;
+}
+
+void WraplandOutput::createOutputDevice(Wl::Registry *registry, quint32 name, quint32 version)
+{
+    Q_ASSERT(!m_device);
+    m_device = registry->createOutputDeviceV1(name, version);
+
+    connect(m_device, &Wl::OutputDeviceV1::removed, this, &WraplandOutput::removed);
+    connect(m_device, &Wl::OutputDeviceV1::done, this, [this]() {
+                disconnect(m_device, &Wl::OutputDeviceV1::done, this, nullptr);
+                connect(m_device, &Wl::OutputDeviceV1::changed, this, &WraplandOutput::changed);
+                Q_EMIT dataReceived();
+    });
+}
+
+void WraplandOutput::updateKScreenOutput(OutputPtr &output)
+{
+    // Initialize primary output
+    output->setEnabled(m_device->enabled() == Wl::OutputDeviceV1::Enablement::Enabled);
+    output->setConnected(true);
+    output->setPrimary(true); // FIXME: wayland doesn't have the concept of a primary display
+    output->setName(name());
+    output->setSizeMm(m_device->physicalSize());
+    output->setPos(m_device->geometry().topLeft().toPoint());
+    output->setRotation(s_rotationMap[m_device->transform()]);
+
+    ModeList modeList;
+    QStringList preferredModeIds;
+    m_modeIdMap.clear();
+    QString currentModeId = QStringLiteral("-1");
+
+    for (const Wl::OutputDeviceV1::Mode &wlMode : m_device->modes()) {
+        ModePtr mode(new Mode());
+        const QString name = modeName(wlMode);
+
+        QString modeId = QString::number(wlMode.id);
+        if (modeId.isEmpty()) {
+            qCDebug(KSCREEN_WAYLAND) << "Could not create mode id from"
+                                     << wlMode.id << ", using" << name << "instead.";
+            modeId = name;
+        }
+
+        if (m_modeIdMap.contains(modeId)) {
+            qCWarning(KSCREEN_WAYLAND) << "Mode id already in use:" << modeId;
+        }
+        mode->setId(modeId);
+
+        // Wrapland gives the refresh rate as int in mHz
+        mode->setRefreshRate(wlMode.refreshRate / 1000.0);
+        mode->setSize(wlMode.size);
+        mode->setName(name);
+
+        if (wlMode.flags.testFlag(Wl::OutputDeviceV1::Mode::Flag::Current)) {
+            currentModeId = modeId;
+        }
+        if (wlMode.flags.testFlag(Wl::OutputDeviceV1::Mode::Flag::Preferred)) {
+            preferredModeIds << modeId;
+        }
+
+        // Update the kscreen => Wrapland mode id translation map
+        m_modeIdMap.insert(modeId, wlMode.id);
+        // Add to the modelist which gets set on the output
+        modeList[modeId] = mode;
+    }
+
+    if (currentModeId == QLatin1String("-1")) {
+        qCWarning(KSCREEN_WAYLAND) << "Could not find the current mode id" << modeList;
+    }
+
+    output->setCurrentModeId(currentModeId);
+    output->setPreferredModes(preferredModeIds);
+    output->setModes(modeList);
+//    output->setScale(m_device->scaleF());
+    output->setType(Utils::guessOutputType(m_device->model(), m_device->model()));
+}
+
+bool WraplandOutput::setWlConfig(Wl::OutputConfigurationV1 *wlConfig,
+                                const KScreen::OutputPtr &output)
+{
+    bool changed = false;
+
+    // enabled?
+    if ((m_device->enabled() == Wl::OutputDeviceV1::Enablement::Enabled)
+            != output->isEnabled()) {
+        changed = true;
+        const auto enablement = output->isEnabled() ? Wl::OutputDeviceV1::Enablement::Enabled :
+                                                      Wl::OutputDeviceV1::Enablement::Disabled;
+        wlConfig->setEnabled(m_device, enablement);
+    }
+
+    // position
+    if (m_device->geometry().topLeft() != output->pos()) {
+        changed = true;
+        wlConfig->setGeometry(m_device, QRectF(output->pos(), m_device->geometry().size()));
+    }
+
+//    // scale
+//    if (!qFuzzyCompare(m_device->scaleF(), output->scale())) {
+//        changed = true;
+//        wlConfig->setScaleF(m_device, output->scale());
+//    }
+
+    // rotation
+    if (toKScreenRotation(m_device->transform()) != output->rotation()) {
+        changed = true;
+        wlConfig->setTransform(m_device, toWraplandTransform(output->rotation()));
+    }
+
+    // mode
+    if (m_modeIdMap.contains(output->currentModeId())) {
+        const int newModeId = m_modeIdMap.value(output->currentModeId(), -1);
+        if (newModeId != m_device->currentMode().id) {
+            changed = true;
+            wlConfig->setMode(m_device, newModeId);
+        }
+    } else {
+        qCWarning(KSCREEN_WAYLAND) << "Invalid kscreen mode id:" << output->currentModeId()
+                                   << "\n\n" << m_modeIdMap;
+    }
+
+    // logical size
+    if (m_device->geometry().size() != output->logicalSize()) {
+        QSizeF size = output->explicitLogicalSize();
+        if (!size.isValid()) {
+            size = output->logicalSize();
+        }
+        changed = true;
+        wlConfig->setGeometry(m_device, QRectF(output->pos(), size));
+    }
+    return changed;
+}
+
+QString WraplandOutput::modeName(const Wl::OutputDeviceV1::Mode &m) const
+{
+    return QString::number(m.size.width()) + QLatin1Char('x') +
+           QString::number(m.size.height()) + QLatin1Char('@') +
+           QString::number(qRound(m.refreshRate/1000.0));
+}
+
+QString WraplandOutput::name() const
+{
+    Q_ASSERT(m_device);
+    return QStringLiteral("%1 %2").arg(m_device->manufacturer(), m_device->model());
+}
+
+QDebug operator<<(QDebug dbg, const WraplandOutput *output)
+{
+    dbg << "WraplandOutput(Id:" << output->id() <<", Name:" << \
+        QString(output->outputDevice()->manufacturer() + QLatin1Char(' ') + \
+        output->outputDevice()->model())  << ")";
+    return dbg;
+}
diff --git a/backends/kwayland/plugins/wrapland/wrapland_output.h b/backends/kwayland/plugins/wrapland/wrapland_output.h
new file mode 100644
index 0000000..5abb065
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland/wrapland_output.h
@@ -0,0 +1,70 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "waylandoutput.h"
+
+#include "output.h"
+
+#include <Wrapland/Client/output_device_v1.h>
+#include <Wrapland/Client/registry.h>
+
+namespace Wrapland
+{
+namespace Client
+{
+class OutputConfigurationV1;
+}
+}
+
+namespace KScreen
+{
+
+class WraplandOutput : public WaylandOutput
+{
+    Q_OBJECT
+
+public:
+    explicit WraplandOutput(quint32 id, QObject *parent = nullptr);
+    ~WraplandOutput() override = default;
+
+    void updateKScreenOutput(KScreen::OutputPtr &output) override;
+
+    QString name() const;
+    QByteArray edid() const override;
+    bool enabled() const override;
+    QRectF geometry() const override;
+
+    Wrapland::Client::OutputDeviceV1* outputDevice() const;
+    void createOutputDevice(Wrapland::Client::Registry *registry, quint32 name, quint32 version);
+
+    bool setWlConfig(Wrapland::Client::OutputConfigurationV1 *wlConfig,
+                     const KScreen::OutputPtr &output);
+
+private:
+    void showOutput();
+    QString modeName(const Wrapland::Client::OutputDeviceV1::Mode &m) const;
+
+    Wrapland::Client::OutputDeviceV1 *m_device;
+    Wrapland::Client::Registry *m_registry;
+
+    // left-hand-side: KScreen::Mode, right-hand-side: Wrapland's mode.id
+    QMap<QString, int> m_modeIdMap;
+};
+
+}
diff --git a/backends/kwayland/wayland_interface.cpp b/backends/kwayland/wayland_interface.cpp
index 3665f8f..63545cb 100644
--- a/backends/kwayland/wayland_interface.cpp
+++ b/backends/kwayland/wayland_interface.cpp
@@ -119,7 +119,7 @@ void WaylandInterface::checkInitialized()
 
 bool WaylandInterface::isInitialized() const
 {
-    return !m_blockSignals && m_initializingOutputs.isEmpty() && outputMap().count();
+    return !m_blockSignals && m_initializingOutputs.isEmpty();
 }
 
 void WaylandInterface::applyConfig(const KScreen::ConfigPtr &newConfig)
diff --git a/backends/kwayland/wayland_interface.h b/backends/kwayland/wayland_interface.h
index 1deed9a..1626b14 100644
--- a/backends/kwayland/wayland_interface.h
+++ b/backends/kwayland/wayland_interface.h
@@ -38,6 +38,7 @@ class WaylandInterface : public QObject
 public:
     enum class Type {
         KWayland = 0,
+        Wrapland,
     };
 
     ~WaylandInterface() override;
-- 
2.26.1


From fe0bad4a15575bd82161d5030222336baaea16e4 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 8 Apr 2020 01:53:26 +0200
Subject: [PATCH 3/3] feat(wayland): add plugin for wlroots based compositors

Adds a plugin that uses the Wrapland library to interact with compositors
supporting the wlr_output_management_unstable_v1 protocol.

If the backend plugin is available at runtime the interface is instantiated in
parallel with other interfaces and whichever interface has success in
retrieving a management global first is used while the other ones are deleted.
---
 backends/kwayland/plugins/CMakeLists.txt      |   7 +
 .../plugins/wrapland-wlr/CMakeLists.txt       |  29 ++
 .../plugins/wrapland-wlr/wrapland-wlr.json    |   7 +
 .../wrapland-wlr/wrapland_interface.cpp       | 261 ++++++++++++++++++
 .../plugins/wrapland-wlr/wrapland_interface.h |  98 +++++++
 .../plugins/wrapland-wlr/wrapland_output.cpp  | 237 ++++++++++++++++
 .../plugins/wrapland-wlr/wrapland_output.h    |  72 +++++
 7 files changed, 711 insertions(+)
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/CMakeLists.txt
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/wrapland-wlr.json
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/wrapland_interface.cpp
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/wrapland_interface.h
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/wrapland_output.cpp
 create mode 100644 backends/kwayland/plugins/wrapland-wlr/wrapland_output.h

diff --git a/backends/kwayland/plugins/CMakeLists.txt b/backends/kwayland/plugins/CMakeLists.txt
index 720efa1..05e0fab 100644
--- a/backends/kwayland/plugins/CMakeLists.txt
+++ b/backends/kwayland/plugins/CMakeLists.txt
@@ -7,5 +7,12 @@ set_package_properties(Wrapland PROPERTIES
 )
 
 if (Wrapland_FOUND)
+    message("Wrapland found with version ${Wrapland_VERSION}.")
+    if (${Wrapland_VERSION} VERSION_GREATER_EQUAL "0.518.80")
+        message("Selecting Wrapland KWinFT and wlroots plugins.")
+        add_subdirectory(wrapland-wlr)
+    else()
+        message("Selecting Wrapland KWinFT plugin (Wrapland version too low for wlroots plugin).")
+    endif()
     add_subdirectory(wrapland)
 endif()
diff --git a/backends/kwayland/plugins/wrapland-wlr/CMakeLists.txt b/backends/kwayland/plugins/wrapland-wlr/CMakeLists.txt
new file mode 100644
index 0000000..c8246b8
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/CMakeLists.txt
@@ -0,0 +1,29 @@
+set(wrapland_SRCS
+    wrapland_interface.cpp
+    wrapland_output.cpp
+    ../../wayland_interface.cpp
+    ../../waylandoutput.cpp
+    ../../wayland_logging.cpp
+    ../../../utils.cpp
+)
+
+include_directories(${CMAKE_SOURCE_DIR}/backends/kwayland)
+
+add_library(LibkscreenWaylandPluginWraplandWlr MODULE ${wrapland_SRCS})
+
+set_target_properties(LibkscreenWaylandPluginWraplandWlr
+    PROPERTIES LIBRARY_OUTPUT_DIRECTORY
+    "${CMAKE_BINARY_DIR}/bin/org.kde.libkscreen.backends/wayland/"
+)
+
+target_link_libraries(LibkscreenWaylandPluginWraplandWlr
+    Qt5::Core
+    Qt5::Gui
+    KF5::Screen
+    WraplandClient
+)
+
+install(
+    TARGETS LibkscreenWaylandPluginWraplandWlr
+    DESTINATION ${PLUGIN_INSTALL_DIR}/org.kde.libkscreen.backends/wayland/
+)
diff --git a/backends/kwayland/plugins/wrapland-wlr/wrapland-wlr.json b/backends/kwayland/plugins/wrapland-wlr/wrapland-wlr.json
new file mode 100644
index 0000000..36a5dd5
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/wrapland-wlr.json
@@ -0,0 +1,7 @@
+{
+    "KPlugin": {
+        "Description": "Wayland backend using Wrapland library's output management interface for wlroots based compositors.",
+        "Id": "LibkscreenWaylandPluginWraplandWlr",
+        "Name": "wrapland-wlr"
+    }
+}
diff --git a/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.cpp b/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.cpp
new file mode 100644
index 0000000..b10a09f
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.cpp
@@ -0,0 +1,261 @@
+/*************************************************************************
+Copyright © 2020   Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "wrapland_interface.h"
+
+#include "waylandbackend.h"
+#include "wrapland_output.h"
+#include "waylandscreen.h"
+
+#include "../../wayland_logging.h"
+
+#include <Wrapland/Client/connection_thread.h>
+#include <Wrapland/Client/event_queue.h>
+#include <Wrapland/Client/registry.h>
+#include <Wrapland/Client/wlr_output_configuration_v1.h>
+#include <Wrapland/Client/wlr_output_manager_v1.h>
+
+#include <QThread>
+
+using namespace KScreen;
+
+WaylandInterface* WraplandFactory::createInterface(QObject *parent)
+{
+    return new WraplandInterface(parent);
+}
+
+WraplandInterface::WraplandInterface(QObject *parent)
+    : WaylandInterface(parent)
+    , m_outputManager(nullptr)
+    , m_registryInitialized(false)
+    , m_kscreenPendingConfig(nullptr)
+{
+}
+
+void WraplandInterface::initConnection(QThread *thread)
+{
+    m_connection = new Wrapland::Client::ConnectionThread;
+
+    connect(m_connection, &Wrapland::Client::ConnectionThread::establishedChanged,
+            this, [this](bool established) {
+            if (established) {
+                setupRegistry();
+            } else {
+                handleDisconnect();
+            }
+     }, Qt::QueuedConnection);
+
+    connect(m_connection, &Wrapland::Client::ConnectionThread::failed, this, [this] {
+        qCWarning(KSCREEN_WAYLAND) << "Failed to connect to Wayland server at socket:"
+                                   << m_connection->socketName();
+        Q_EMIT connectionFailed(m_connection->socketName());
+    });
+
+    thread->start();
+    m_connection->moveToThread(thread);
+    m_connection->establishConnection();
+}
+
+Wrapland::Client::WlrOutputManagerV1* WraplandInterface::outputManager() const
+{
+    return m_outputManager;
+}
+
+bool WraplandInterface::isInitialized() const
+{
+    return m_registryInitialized && m_outputManager != nullptr
+            && WaylandInterface::isInitialized();
+}
+
+void WraplandInterface::handleDisconnect()
+{
+    qDeleteAll(m_outputMap);
+    m_outputMap.clear();
+
+    // Clean up
+    if (m_queue) {
+        delete m_queue;
+        m_queue = nullptr;
+    }
+
+    m_connection->deleteLater();
+    m_connection = nullptr;
+
+    WaylandInterface::handleDisconnect();
+}
+
+void WraplandInterface::setupRegistry()
+{
+    m_queue = new Wrapland::Client::EventQueue(this);
+    m_queue->setup(m_connection);
+
+    m_registry = new Wrapland::Client::Registry(this);
+
+    connect(m_registry, &Wrapland::Client::Registry::wlrOutputManagerV1Announced,
+            this, [this](quint32 name, quint32 version) {
+                m_outputManager = m_registry->createWlrOutputManagerV1(name, version, m_registry);
+
+                connect(m_outputManager, &Wrapland::Client::WlrOutputManagerV1::head,
+                        this, &WraplandInterface::addHead);
+
+                connect(m_outputManager, &Wrapland::Client::WlrOutputManagerV1::done,
+                        this, [this] {
+                    // We only need to process this once in the beginning.
+                    disconnect(m_outputManager,
+                               &Wrapland::Client::WlrOutputManagerV1::done, this, nullptr);
+                    unblockSignals();
+                    checkInitialized();
+                });
+                m_outputManager->setEventQueue(m_queue);
+            }
+    );
+
+    connect(m_registry, &Wrapland::Client::Registry::interfacesAnnounced,
+            this, [this] {
+                m_registryInitialized = true;
+                checkInitialized();
+            }
+    );
+
+    m_registry->setEventQueue(m_queue);
+    m_registry->create(m_connection);
+    m_registry->setup();
+}
+
+void WraplandInterface::addHead(Wrapland::Client::WlrOutputHeadV1 *head)
+{
+    auto output = new WraplandOutput(++m_outputId, head, this);
+    addOutput(output);
+}
+
+void WraplandInterface::insertOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<WraplandOutput*>(output);
+    m_outputMap.insert(out->id(), out);
+}
+
+WaylandOutput* WraplandInterface::takeOutput(WaylandOutput *output)
+{
+    auto *out = static_cast<WraplandOutput*>(output);
+    return m_outputMap.take(out->id());
+}
+
+void WraplandInterface::updateConfig(KScreen::ConfigPtr &config)
+{
+    config->setSupportedFeatures(Config::Feature::Writable | Config::Feature::PerOutputScaling);
+    config->setValid(m_connection->display());
+
+    //Removing removed outputs
+    const KScreen::OutputList outputs = config->outputs();
+    for (const auto &output : outputs) {
+        if (!m_outputMap.contains(output->id())) {
+            config->removeOutput(output->id());
+        }
+    }
+
+    // Add KScreen::Outputs that aren't in the list yet, handle primaryOutput
+    KScreen::OutputList kscreenOutputs = config->outputs();
+    for (const auto &output : m_outputMap) {
+        KScreen::OutputPtr kscreenOutput = kscreenOutputs[output->id()];
+        if (!kscreenOutput) {
+            kscreenOutput = output->toKScreenOutput();
+            kscreenOutputs.insert(kscreenOutput->id(), kscreenOutput);
+        } else {
+            output->updateKScreenOutput(kscreenOutput);
+        }
+        if (kscreenOutput && m_outputMap.count() == 1) {
+            kscreenOutput->setPrimary(true);
+        } else if (m_outputMap.count() > 1) {
+            // primaryScreen concept doesn't exist in Wayland, so we don't set one
+        }
+    }
+    config->setOutputs(kscreenOutputs);
+}
+
+QMap<int, WaylandOutput*> WraplandInterface::outputMap() const
+{
+    QMap<int, WaylandOutput*> ret;
+
+    auto it = m_outputMap.constBegin();
+    while (it != m_outputMap.constEnd()) {
+        ret[it.key()] = it.value();
+        ++it;
+    }
+    return ret;
+}
+
+void WraplandInterface::tryPendingConfig()
+{
+    if (!m_kscreenPendingConfig) {
+        return;
+    }
+    applyConfig(m_kscreenPendingConfig);
+    m_kscreenPendingConfig = nullptr;
+}
+
+void WraplandInterface::applyConfig(const KScreen::ConfigPtr &newConfig)
+{
+    using namespace Wrapland::Client;
+
+    // Create a new configuration object
+    auto *wlConfig = m_outputManager->createConfiguration();
+    wlConfig->setEventQueue(m_queue);
+
+    bool changed = false;
+
+    if (signalsBlocked()) {
+        /* Last apply still pending, remember new changes and apply afterwards */
+        m_kscreenPendingConfig = newConfig;
+        return;
+    }
+
+    for (const auto &output : newConfig->outputs()) {
+        changed |= m_outputMap[output->id()]->setWlConfig(wlConfig, output);
+    }
+
+    if (!changed) {
+        return;
+    }
+
+    // We now block changes in order to compress events while the compositor is doing its thing
+    // once it's done or failed, we'll trigger configChanged() only once, and not per individual
+    // property change.
+    connect(wlConfig, &WlrOutputConfigurationV1::succeeded, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+    connect(wlConfig, &WlrOutputConfigurationV1::failed, this, [this, wlConfig] {
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+    connect(wlConfig, &WlrOutputConfigurationV1::cancelled, this, [this, wlConfig] {
+        // This should never be received since we apply the new config directly. But in case we just
+        // do the same as on failed.
+        wlConfig->deleteLater();
+        unblockSignals();
+        Q_EMIT configChanged();
+        tryPendingConfig();
+    });
+
+    // Now block signals and ask the compositor to apply the changes.
+    blockSignals();
+    wlConfig->apply();
+}
diff --git a/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.h b/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.h
new file mode 100644
index 0000000..ed3d8a9
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/wrapland_interface.h
@@ -0,0 +1,98 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "wayland_interface.h"
+#include "config.h"
+
+namespace Wrapland
+{
+namespace Client
+{
+class ConnectionThread;
+class EventQueue;
+class Registry;
+class WlrOutputManagerV1;
+class WlrOutputHeadV1;
+}
+}
+
+namespace KScreen
+{
+class Output;
+class WraplandOutput;
+class WaylandOutput;
+class WaylandScreen;
+
+class WraplandFactory : public WaylandFactory
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.kde.libkscreen.waylandinterface" FILE "wrapland-wlr.json")
+
+public:
+    WaylandInterface* createInterface(QObject *parent = nullptr) override;
+};
+
+class WraplandInterface : public WaylandInterface
+{
+    Q_OBJECT
+
+public:
+    explicit WraplandInterface(QObject *parent = nullptr);
+    ~WraplandInterface() override = default;
+
+    void initConnection(QThread *thread) override;
+    bool isInitialized() const override;
+
+    QMap<int, WaylandOutput*> outputMap() const override;
+
+    void applyConfig(const KScreen::ConfigPtr &newConfig) override;
+    void updateConfig(KScreen::ConfigPtr &config) override;
+
+    Wrapland::Client::WlrOutputManagerV1* outputManager() const;
+
+protected:
+    void insertOutput(WaylandOutput *output) override;
+    WaylandOutput* takeOutput(WaylandOutput *output) override;
+    void handleDisconnect() override;
+
+private:
+    void setupRegistry();
+    void addHead(Wrapland::Client::WlrOutputHeadV1 *head);
+    void tryPendingConfig();
+
+    Wrapland::Client::ConnectionThread *m_connection;
+    Wrapland::Client::EventQueue *m_queue;
+
+    Wrapland::Client::Registry *m_registry;
+    Wrapland::Client::WlrOutputManagerV1 *m_outputManager;
+
+    // Wrapland names as keys
+    QMap<int, WraplandOutput*> m_outputMap;
+
+    // Wrapland names
+    int m_lastOutputId = -1;
+
+    bool m_registryInitialized;
+    bool m_blockSignals;
+    KScreen::ConfigPtr m_kscreenPendingConfig;
+
+    int m_outputId = 0;
+};
+
+}
diff --git a/backends/kwayland/plugins/wrapland-wlr/wrapland_output.cpp b/backends/kwayland/plugins/wrapland-wlr/wrapland_output.cpp
new file mode 100644
index 0000000..53f7a55
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/wrapland_output.cpp
@@ -0,0 +1,237 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#include "wrapland_output.h"
+
+#include "wrapland_interface.h"
+
+#include "waylandbackend.h"
+#include "waylandconfig.h"
+#include "../utils.h"
+
+#include <mode.h>
+#include <edid.h>
+
+#include "../../wayland_logging.h"
+
+#include <Wrapland/Client/wlr_output_configuration_v1.h>
+
+using namespace KScreen;
+namespace Wl = Wrapland::Client;
+
+const QMap<Wl::WlrOutputHeadV1::Transform, Output::Rotation>
+s_rotationMap = {
+    {Wl::WlrOutputHeadV1::Transform::Normal, Output::None},
+    {Wl::WlrOutputHeadV1::Transform::Rotated90, Output::Right},
+    {Wl::WlrOutputHeadV1::Transform::Rotated180, Output::Inverted},
+    {Wl::WlrOutputHeadV1::Transform::Rotated270, Output::Left},
+    {Wl::WlrOutputHeadV1::Transform::Flipped, Output::None},
+    {Wl::WlrOutputHeadV1::Transform::Flipped90, Output::Right},
+    {Wl::WlrOutputHeadV1::Transform::Flipped180, Output::Inverted},
+    {Wl::WlrOutputHeadV1::Transform::Flipped270, Output::Left}
+};
+
+Output::Rotation toKScreenRotation(const Wl::WlrOutputHeadV1::Transform transform)
+{
+    auto it = s_rotationMap.constFind(transform);
+    return it.value();
+}
+
+Wl::WlrOutputHeadV1::Transform toWraplandTransform(const Output::Rotation rotation)
+{
+    return s_rotationMap.key(rotation);
+}
+
+WraplandOutput::WraplandOutput(quint32 id, Wrapland::Client::WlrOutputHeadV1 *head,
+                               WraplandInterface *parent)
+    : WaylandOutput(id, parent)
+    , m_head(head)
+{
+    connect(m_head, &Wl::WlrOutputHeadV1::changed, this, &WraplandOutput::changed);
+    connect(m_head, &Wl::WlrOutputHeadV1::removed, this, &WraplandOutput::removed);
+
+
+    auto manager = parent->outputManager();
+    connect(manager, &Wl::WlrOutputManagerV1::done,
+        this, [this, manager]() {
+            disconnect(manager, &Wl::WlrOutputManagerV1::done, this, nullptr);
+            Q_EMIT dataReceived();
+        }
+    );
+}
+
+bool WraplandOutput::enabled() const
+{
+    return m_head != nullptr;
+}
+
+QByteArray WraplandOutput::edid() const
+{
+    // wlroots protocol does not provide edid information.
+    return QByteArray();
+}
+
+bool portraitMode(Wrapland::Client::WlrOutputHeadV1 *head)
+{
+    auto transform = head->transform();
+    return transform == Wl::WlrOutputHeadV1::Transform::Rotated90
+            || transform == Wl::WlrOutputHeadV1::Transform::Rotated270
+            || transform == Wl::WlrOutputHeadV1::Transform::Flipped90
+            || transform == Wl::WlrOutputHeadV1::Transform::Flipped270;
+}
+
+QRectF WraplandOutput::geometry() const
+{
+    auto modeSize = m_head->currentMode()->size();
+
+    // Rotate and scale.
+    if (portraitMode(m_head)) {
+        modeSize.transpose();
+    }
+
+    modeSize = modeSize / m_head->scale();
+
+    return QRectF(m_head->position(), modeSize);
+}
+
+Wrapland::Client::WlrOutputHeadV1 *WraplandOutput::outputHead() const
+{
+    return m_head;
+}
+
+QString modeName(const Wl::WlrOutputModeV1 *mode)
+{
+    return QString::number(mode->size().width()) + QLatin1Char('x') +
+           QString::number(mode->size().height()) + QLatin1Char('@') +
+           QString::number( qRound(mode->refresh() / 1000.0) );
+}
+
+void WraplandOutput::updateKScreenOutput(OutputPtr &output)
+{
+    // Initialize primary output
+    output->setEnabled(m_head->enabled());
+    output->setConnected(true);
+    output->setPrimary(true); // FIXME: wayland doesn't have the concept of a primary display
+    output->setName(name());
+    output->setSizeMm(m_head->physicalSize());
+    output->setPos(m_head->position());
+    output->setRotation(s_rotationMap[m_head->transform()]);
+
+    ModeList modeList;
+    QStringList preferredModeIds;
+    m_modeIdMap.clear();
+    QString currentModeId = QStringLiteral("-1");
+
+    auto currentMode = m_head->currentMode();
+
+    int modeCounter = 0;
+    for (auto wlMode : m_head->modes()) {
+        const auto modeId = QString::number(++modeCounter);
+
+        ModePtr mode(new Mode());
+
+        mode->setId(modeId);
+
+        // Wrapland gives the refresh rate as int in mHz.
+        mode->setRefreshRate(wlMode->refresh() / 1000.0);
+        mode->setSize(wlMode->size());
+        mode->setName(modeName(wlMode));
+
+        if (wlMode->preferred()) {
+            preferredModeIds << modeId;
+        }
+        if (currentMode == wlMode) {
+            currentModeId = modeId;
+        }
+
+        // Update the KScreen => Wrapland mode id translation map.
+        m_modeIdMap.insert(modeId, wlMode);
+
+        // Add to the modelist which gets set on the output.
+        modeList[modeId] = mode;
+    }
+
+    if (currentModeId == QLatin1String("-1")) {
+        qCWarning(KSCREEN_WAYLAND) << "Could not find the current mode id" << modeList;
+    }
+
+    output->setCurrentModeId(currentModeId);
+    output->setPreferredModes(preferredModeIds);
+    output->setModes(modeList);
+    output->setScale(m_head->scale());
+    output->setType(Utils::guessOutputType(m_head->name(), m_head->name()));
+}
+
+bool WraplandOutput::setWlConfig(Wl::WlrOutputConfigurationV1 *wlConfig,
+                                 const KScreen::OutputPtr &output)
+{
+    bool changed = false;
+
+    // enabled?
+    if (m_head->enabled() != output->isEnabled()) {
+        changed = true;
+    }
+
+    // In any case set the enabled state to initialize the output's native handle.
+    wlConfig->setEnabled(m_head, output->isEnabled());
+
+    // position
+    if (m_head->position() != output->pos()) {
+        changed = true;
+        wlConfig->setPosition(m_head, output->pos());
+    }
+
+    // scale
+    if (!qFuzzyCompare(m_head->scale(), output->scale())) {
+        changed = true;
+        wlConfig->setScale(m_head, output->scale());
+    }
+
+    // rotation
+    if (toKScreenRotation(m_head->transform()) != output->rotation()) {
+        changed = true;
+        wlConfig->setTransform(m_head, toWraplandTransform(output->rotation()));
+    }
+
+    // mode
+    if (m_modeIdMap.contains(output->currentModeId())) {
+        auto newMode = m_modeIdMap.value(output->currentModeId(), nullptr);
+        if (newMode != m_head->currentMode()) {
+            changed = true;
+            wlConfig->setMode(m_head, newMode);
+        }
+    } else {
+        qCWarning(KSCREEN_WAYLAND) << "Invalid kscreen mode id:" << output->currentModeId()
+                                   << "\n\n" << m_modeIdMap;
+    }
+
+    return changed;
+}
+
+QString WraplandOutput::name() const
+{
+    Q_ASSERT(m_head);
+    return m_head->description();
+}
+
+QDebug operator<<(QDebug dbg, const WraplandOutput *output)
+{
+    dbg << "WraplandOutput(Id:" << output->id() <<", Name:" << \
+        QString(output->outputHead()->name() + QLatin1Char(' ') + \
+        output->outputHead()->description())  << ")";
+    return dbg;
+}
diff --git a/backends/kwayland/plugins/wrapland-wlr/wrapland_output.h b/backends/kwayland/plugins/wrapland-wlr/wrapland_output.h
new file mode 100644
index 0000000..2c70456
--- /dev/null
+++ b/backends/kwayland/plugins/wrapland-wlr/wrapland_output.h
@@ -0,0 +1,72 @@
+/*************************************************************************
+Copyright © 2020 Roman Gilg <subdiff@gmail.com>
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+**************************************************************************/
+#pragma once
+
+#include "waylandoutput.h"
+
+#include "output.h"
+
+#include <Wrapland/Client/wlr_output_manager_v1.h>
+#include <Wrapland/Client/registry.h>
+
+namespace Wrapland
+{
+namespace Client
+{
+class WlrOutputConfigurationV1;
+class WlrOutputHeadV1;
+class WlrOutputModeV1;
+}
+}
+
+namespace KScreen
+{
+class WraplandInterface;
+
+class WraplandOutput : public WaylandOutput
+{
+    Q_OBJECT
+
+public:
+    explicit WraplandOutput(quint32 id, Wrapland::Client::WlrOutputHeadV1 *head,
+                            WraplandInterface *parent);
+    ~WraplandOutput() override = default;
+
+    void updateKScreenOutput(KScreen::OutputPtr &output) override;
+
+    QString name() const;
+    QByteArray edid() const override;
+    bool enabled() const override;
+    QRectF geometry() const override;
+
+    Wrapland::Client::WlrOutputHeadV1* outputHead() const;
+
+    bool setWlConfig(Wrapland::Client::WlrOutputConfigurationV1 *wlConfig,
+                     const KScreen::OutputPtr &output);
+
+private:
+    void showOutput();
+
+    Wrapland::Client::WlrOutputHeadV1 *m_head;
+    Wrapland::Client::Registry *m_registry;
+
+    // left-hand-side: KScreen::Mode, right-hand-side: Wrapland's WlrOutputModeV1
+    QMap<QString, Wrapland::Client::WlrOutputModeV1*> m_modeIdMap;
+};
+
+}
-- 
2.26.1

